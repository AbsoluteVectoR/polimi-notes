# Pthread

The POSIX thread (pthread) library is a programming library that provides a standard interface for creating and managing threads in a C or C++ program. It is based on the POSIX Threads standard, which defines a set of functions and data types for creating and controlling threads in a portable and consistent manner. PThread is a widely-used implementation of this standard, and is commonly used in multi-threaded programming on Linux and other Unix-like operating systems.

PThread is a low-level threading library that allows developers to have explicit and fine-grained control over the behavior of their multithreaded programs. This level of control can be useful in some cases, but it can also make the programming of concurrent applications more complex and error-prone.

## Basic recap of threads 

A thread is a unit of execution within a process that can be scheduled and executed by the operating system. Threads have their own local resources, such as stack and register state, but they also have access to the shared resources of the process in which they run. This allows multiple threads to cooperate and coordinate their actions in order to achieve a common goal.
Threads can communicate with each other implicitly by reading and writing to shared system resources, such as memory locations. However, this can lead to synchronization issues, where two or more threads attempt to access the same resource at the same time. In order to avoid these issues, the programmer must use synchronization mechanisms to ensure that threads access shared resources in a safe and orderly manner.

Threads created in a pthread application are not hierarchically organized. In the pthread library, threads are considered to be independent entities that can be scheduled and executed by the operating system in an arbitrary order. 

## Main Pthread functions 

pthread_create

In the pthread library, it is possible to pass arguments of any type to a thread that is created using the pthread_create function. To do this, the programmer must define a struct that contains the necessary arguments and pass a pointer to this struct as the fourth argument to pthread_create. The thread function (the third argument to pthread_create) can then use the pointer to access the arguments and use them as needed.

For example, suppose you have a thread function called "my_thread_func" that takes two arguments: an integer and a string. You could create a thread that executes this function and passes the arguments 10 and "hello" as follows:

````Cpp
struct thread_args {
    int arg1;
    char *arg2;
};

void *my_thread_func(void *args) {
    //this is the C routine that the thread 
    // will execute once it is created.
    
    struct thread_args *my_args = (struct thread_args *)args;
    int arg1 = my_args->arg1;
    char *arg2 = my_args->arg2;

    // Use the arguments in the thread function...
}

int main() {
    pthread_t my_thread;
    struct thread_args my_args;

    my_args.arg1 = 10;
    my_args.arg2 = "hello";

    pthread_create(&my_thread, NULL, my_thread_func, &my_args);

    // Other code...
}
````

In this example, the struct thread_args is defined to contain the two arguments that will be passed to the thread function. The main thread creates an instance of this struct and initializes its fields with the desired arguments. It then passes a pointer to this struct as the fourth argument to pthread_create. Inside the thread function, the pointer is cast to the correct type and the arguments are extracted from the struct and used as needed.

This approach allows you to pass arguments of any type to a thread function in a pthread program, as long as you define a struct that can hold the necessary data and pass a pointer to this struct to pthread_create.

Pthread_join

Pthread_join is a function used in the POSIX thread (pthread) library to synchronize the execution of threads. It allows one thread to wait for the completion of another thread. When a thread calls pthread_join, it is suspended until the target thread (the thread being joined) completes its execution. The pthread_join function returns the exit status of the target thread, which can be used to determine whether it terminated successfully or not.

````Cpp
#include <pthread.h>
#include <stdio.h>

void *my_thread_func(void *args) {
    // Do some work in the thread...
    return NULL;
}

int main() {
    pthread_t my_thread;

    pthread_create(&my_thread, NULL, my_thread_func, NULL);

    // Do some work in the main thread...

    pthread_join(my_thread, NULL);

    // Continue execution after the thread has completed...

    return 0;
}
````


Pthread barriers

````cpp
#include <pthread.h>
#include <stdio.h>

pthread_barrier_t my_barrier;

void *my_thread_func(void *args) {
    // Do some work in the thread...

    pthread_barrier_wait(&my_barrier);

    // Continue execution after the barrier is reached...

    return NULL;
}

int main() {
    pthread_barrier_init(&my_barrier, NULL, 2);

    pthread_t my_thread;
    pthread_create(&my_thread, NULL, my_thread_func, NULL);

    // Do some work in the main thread...

    pthread_barrier_wait(&my_barrier);

    // Continue execution after the barrier is reached...

    pthread_join(my_thread, NULL);

    return 0;
}

````

Both the main thread and the new thread do some work, and then each calls the pthread_barrier_wait function to wait for the other thread to reach the barrier. When both threads have reached the barrier, they are released and can continue execution.

Cond and mutex 

A mutex variable is a special type of lock that allows only one thread to hold it at any given time. When a thread acquires a mutex, it prevents other threads from acquiring the same mutex, ensuring that only one thread can access the protected resource at a time.
When you call the pthread_cond_wait function, the mutex that is associated with the condition variable is released. This allows other threads to acquire the mutex and access the shared resource or data structure that is protected by the mutex.

````cpp

#include <pthread.h>
#include <stdio.h>

pthread_mutex_t my_mutex;
pthread_cond_t my_cond;
int my_shared_var = 0;

void *my_thread_func(void *args) {
    pthread_mutex_lock(&my_mutex);

    // Wait for the condition to be signaled
    while (my_shared_var == 0) {
        pthread_cond_wait(&my_cond, &my_mutex);
    }

    // Do some work with the shared variable...

    pthread_mutex_unlock(&my_mutex);
    return NULL;
}

int main() {
    pthread_mutex_init(&my_mutex, NULL);
    pthread_cond_init(&my_cond, NULL);

    pthread_t my_thread;
    pthread_create(&my_thread, NULL, my_thread_func, NULL);

    // Do some work in the main thread...
    pthread_mutex_lock(&my_mutex);
    my_shared_var = 1;
    pthread_cond_signal(&my_cond);
    pthread_mutex_unlock(&my_mutex);

    pthread_join(my_thread, NULL);

    return 0;
}


````