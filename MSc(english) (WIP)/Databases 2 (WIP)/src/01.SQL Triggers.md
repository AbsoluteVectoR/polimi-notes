# SQL Triggers 

Main paradigm to reason: 

````
EVENT -> CONDITION -> ACTION
````

Main structure to make triggers: 

````sql
create trigger <trigger_name>
{before | after}
{insert | delete | update [of <column>]} on <table>
[referencing (to put aliases on old, new, etc)]
[for each {row | statement}]
[when condition]
BEGIN
[my action]
END
````

- Use triggers to guarantee that when a specific operation is performed, related actions are performed
- Do not define triggers that duplicate features already built into the DBMS. For example, do not define triggers to reject bad data if you can do the same checking through aeclarative integrity constraints 
Limit the size of triggers. If the logic for your trigger requires much more than 60 lines of code, it is better to include most of the code in a stored procedure and call the procedure from the trigger. Use triggers only for centralized, global operations that should be fired for the triggering statement, regardless of which user or database application issues the statement. Avoid recursive triggers if not absolutely necessary. Trigger may•
: : :  fire recursively until the DBMs runs out of memory. 

Use triggers : : : · .Yro guarantee properties of data that cannot be specified by means of integrity constraints 


Importante perché solitamente ci sono tante applicazioni diverse che
accedono allo stesso DB. Quindi se ho qualche regola da far rispettare
in generale è molto meglio averla nel DB che a livello Applicativo nelle
diverse applicazioni. Potrebbero crearsi inconsistenze e casini.



Triggers are powerfull but also complicated because cascading policies. 
They could be bugs in triggers obviously, also because a **cascading** triggers: a trigger activates another trigger. Some systems block cascading of triggers. Also it could happen **recursive cascading** . 

````SQL
CREATE TRIGGER [schema_name.]_trigger_name 
{ BEFORE | AFTER | INSTEAD OF } {INSERT |  UPDATE | DELETE} ON schema_name
{ FOR EACH ROW}
BEGIN 
{ WHEN ....}
UPDATE schema_name SET attribute_name = .... 
{ WHERE .... }
END;
````

````sql 
DROP TRIGGER trigger_name;
````

````SQL
INSERT INTO NAMES 
VALUES (23,"rick");

SELECT * FROM NAMES;
````


sito per esercitarsi: [Online SQL Compiler (tutorialspoint.com)](https://www.tutorialspoint.com/execute_sql_online.php) 

usi la keyword new per selezionare la nuova entry

> Remember that every time you have an update, you usually also have a 'where'

````sql
SELECT * FROM table1 AS X JOIN table2 AS Y ON X.attribute=Y.attribute
````

Also exist 'IF EXISTS ... ELSE ... '

Cascading is generally bad and in some DBMS is even forbidden. 

### Termination analysis

Draw down the triggering graph where each node is atrigger and each arc from a trigger i to j is present only if T_i effects may activate T_j . 

## View Materialization 

When a view is mentioned in a SELECT query the query
processor rewrites the query using the view definition,
so that the actually executed query only uses the base
tables of the view
•
When the queries to a view are more frequent than the
updates on the base tables that change the view
content, then view materialization can be an option
•
Storing the results of the query that defines a the view in a
table
•
Some systems support the CREATE MATERIALIZED
VIEW command, which makes the view automatically
materialized by the DBMS
•
An alternative is to implement the materialization by
means of triggers

![](Pasted%20image%2020230122083324.png)

Actually ‘FOR EACH ROW’ means for each of the matched rows that get either updated or deleted. In other words, we can say that trigger is not applied to each row, it just says to execute the trigger body for each affected table row. We can illustrate this by the following example −


A `REFERENCING` clause in a SQL trigger is used to specify the name of a transition table that is used to hold the old and/or new values of the rows that are affected by the trigger.

Here's an example of a trigger that uses the `REFERENCING` :

````sql
CREATE TRIGGER update_jedi_rank 
AFTER UPDATE ON jedi 
FOR EACH ROW REFERENCING OLD AS old_jedi NEW AS new_jedi 
BEGIN     
	IF (old_jedi.rank <> new_jedi.rank) 
		THEN         
		INSERT INTO jedi_rank_history (jedi_name, old_rank, new_rank)         
		VALUES (new_jedi.name, old_jedi.rank, new_jedi.rank);     
	END IF;
END;
````

````sql
CREATE TRIGGER update_planet_distance
AFTER UPDATE ON planets
FOR EACH ROW
BEGIN
    DECLARE @planet_name VARCHAR(255) = NEW.name;
    DECLARE @new_distance FLOAT = NEW.distance_from_earth;
    DECLARE @old_distance FLOAT = OLD.distance_from_earth;

    IF (@new_distance > @old_distance)
    BEGIN
        INSERT INTO planet_distance_history (planet_name, old_distance, new_distance)
        VALUES (@planet_name, @old_distance, @new_distance);
    END;
END;
````



In this case, the function will return 'Tony Montana' as the main character, as it is the first non-null value of the list.

On the other hand, the `IS NULL`/`IS NOT NULL` operators are used to test for NULL values in a column or expression. For example,



This query will return all rows from the "movies" table where the value of the "main_character" column is NULL.

The `EXISTS` operator returns true if the subquery returns at least one row. For example,


## Some useful functions

### Coalesce and others

- `COALESCE` function returns the first non-NULL value in a list of expressions. It can be used to provide a default value when a `NULL` value is encountered.

````sql
SELECT COALESCE(NULL, 'Tony Montana', 'Scarface') AS "Main Character";`
````

- `IS NULL`/`IS NOT NULL` operators are used to test for `NULL` values in a column or expression 

````sql
SELECT * FROM movies WHERE main_character IS NULL;
````

- `EXISTS` operator is used to check if a row exists in a subquery.

````sql
SELECT * FROM movies 
WHERE EXISTS
(SELECT 1 FROM box_office WHERE box_office.movie_id = movies.id AND box_office.revenue > 10000);
````

- `IFNULL` common pattern: 

````sql
DECLARE X AS INTEGER
IFNULL(<SELECT_QUERY_HERE>, 0) INTO X

IF (X<>0)
THEN
	\\
ELSE
	\\
ENDIF;
````

### INSERT INTO 

It is possible to add values for all the columns of a table using the `INSERT INTO` statement. 

````sql
INSERT INTO _table_name_  
VALUES (_value1_, _value2_, _value3_, ...);
````

