
# Scheme

> Scheme ... a lot of parentheses.


- Scheme dialect (which is in turn a language in the Lisp family) can be used in a functional style (but not purely functional)
- Dynamically typed: the type of a value is determined at runtime, rather than at compile-time. In dynamic typing, you don't have to specify the type of a variable when you declare it, and the type of the value stored in the variable can change dynamically during the execution of the program. (for example C++ is statically typed).
- Functions are first class objects. 
````Scheme 
(define (fold binop n e)
  (if (<= n e)
      e
      (binop (fold binop (- n 1) e) n)))
````
in this example I can pass any binary function to the function like any other object. 
- Scheme is lexical scoped (also statically scoped): the scope of a variable is determined by its location in the source code, more properly a variable always refers to its top-level environment. For example, if a variable is defined within a function, it will only be visible within that function and will not be accessible outside of it. This makes it easier to understand and manage the scope of variables in a program, because you can determine their visibility simply by looking at the source code. On the other hand, in dynamic scoping, the scope of a variable is determined by the order of function calls rather than its position in the source code. In most programming languages including C, C++, and Java, variables are always statically (or lexical) scoped.
- Homoiconicity: it means that there is no distinction between code and data and that for example statements, like expressions, are nestable.: `(+ 42 (if (< 1 0) 23 0))`. The `if` statement is nested inside the `+` expression and is treated as just another expression with a value.

### Variables and Let Expressions

- Booleans: ````#t, #f````
- Numbers: ````42, 1.23e+33, 23/169, 12+4i````
- Characters: ````#a, #Z````
- Symbols: ````a-symbol, another-symbol?, indeed!````
- Vectors: ````#(1 2 3 4)```` 
- Strings: ````"this is a string"````
- Pairs and Lists: ````(1 2 #\a), (a . b),()````


Let is not assignment, is creating a new variable. Let is used to bind variables. We say the variables are _bound_ to the values by the let.

```` Scheme
(let ( (<var> <expr>) (<var> <expr>) ... )
  <let body> 
)

//examples 

(let ((x 3) (y 2)) ;It's parallel 
  (+ x y)) ; 5 
)

(let* ((x 3) (y 2))  ; let* it's sequential
  (+ x y)) ; 5 
)
````

Variables created by let are local. To create top-level bindings there is  
define:  
````Scheme
(define x 12)  
(define y #(1 2 3))
````

We can perform sequence of operations (a block of procedural code) using `(begin ...)`.  

## Lambda Expressions

`lambda` is used to encapsulate piece of code inside the code, without the evaluation. You can use the `lambda` special form to create anonymous functions. Any lambda expression can be evaluated in any moment using `()`.


````Scheme
(lambda (<parameters>) <body> )

; here an example where I use "immediately" the lambda

> (display ((lambda (x y) (- x y))  2 3))
-1
````

`lambda` expression evaluates to an anonymous function that, when applied (executed), takes k arguments and returns the result of evaluating `expr`. As you would expect, the parameters are lexically scoped and can only be used in `expr`.

### Defining Named Functions

If you go to the trouble of defining a function, you often want to save it for later use. You accomplish this by binding the result of a `lambda` to a variable using `define`, just as you would with any other value.

````Scheme
(define (double x)
        (* 2 x))

(define (centigrade-to-fahrenheit c)
        (+ (* 1.8 c) 32.0))
````

````Scheme
(define (function x . rest)
  (displayln x)
  (display rest))

; notice how Scheme bounds the parameters 

> (function 1 2 3)
1 
(2 3)
````

In functions parameters are passed by values. So a function doesn´t change the value of the parameters. In these cases I should use a macro. 
````Scheme
(define (++ x)
	(set! x (+ x 1))
x)

>(define a 42)
>(++ a)
43

>a 
>42 
````

NB: in general, procedures with side effects have a trailing bang (!) character.


## Macros

You could create new syntax with macros. Scheme has a very powerful Turing-complete macro system (note that Scheme is cool because you can define recursive macros). A macro is simply a text substitution of the body of the macro over the macro name.  

> You don't evaluate macros, you expand them. 

Macros are of course expanded at compile-time and they are defined in this way:
````Scheme
(define-syntax <rule_name> 
  (syntax-rules () ;variant of the rule name
  ((_ <first_parameter_here> <second_param> ...)
  <body_pattern_match>
  )))
````

In functions parameters are passed by values while in macros the parameters are passed by name. 

````Scheme
(define-syntax while
(syntax-rules () ; no other needed keywords
((_ parameter ...)    ; pattern 1  
(let loop () ; expansion of P
	(when condition
		(begin
		body ...
		(loop)))
		
((_ parameter1 parameter2 ...)    ; pattern 2 
(let loop2 () ; expansion of P
	(when condition
		(begin
		body ...
		(loop2)))
		
))))
````

Note that `_` is just a shorthand notation and `...` is a way to say that you can have multiple elements as body. 

### Hygiene of macros 

Scheme macros are hygienic: this means that symbols used in their definitions are actually replaced with special symbols not used anywhere else in the program. In this way it's impossible to have name clashes when the macro is expanded. For example a macro could be expanded into a piece of code that contains a label that has the same name of a variable used by the user for example -> so the name clash.

## Iteration


## Recursion


Recur­sion is a favored tech­nique in [func­tional program­ming](https://beautifulracket.com/appendix/glossary.html#functional-programming) because it helps avoid [muta­tion](https://beautifulracket.com/appendix/glossary.html#mutation) of values. The first version of our factorial func­tion mutated the vari­able product on each pass. The second did not.
The most important thing of recursion is tail recur­sion. A tail recursive function is one that returns the result of the recursive call back without alteration. Racket compilers handle tail recursion very efficiently, as efficiently as a program that just uses loops instead of recursion. 


````Scheme 
(define (fold op n e)
  (fold-helper op n e n))

(define (fold-helper op n e acc)
  (if (<= n e)
      acc
      (fold-helper op (- n 1) e (op acc (- n 1)))))

>(display (fold + 10 1))
> 55
>(+ 10 9 8 7 6 5 4 3 2 1)
````

The difference between a tail recursive function and a not tail recursive one is that at each time the operation is done **before** the recursion call: in this way ¨there are just calls of functions on the stack and not pending operations¨.
This is **NOT** tail recursive, since after the recursion it performs an multiplication. 
```Scheme
(define (std-factorial n)
  (if (zero? n)
      1
      (* n (std-factorial (- n 1)))))
````
To turn this into a tail recursion function it's necessary an accumulator. This is a typical pattern: use an helper function with an additional parameter which accumulates the answer (the accumulator) to convert a non-tail recursive function into a tail recursive one. 
````Scheme
(define (factorial n)
  (acc-factorial n 1))

;; auxiliary function that takes an additional parameter (the accumulator,
;; i.e. the result computed so far)

(define (factorial n)
  (acc-factorial n 1))


;; auxiliary function that takes an additional parameter (the accumulator,
;; i.e. the result computed so far)
(define (acc-factorial n sofar)
  (if (zero? n)
      sofar
      (acc-factorial (- n 1) (* sofar n))))
````

Another example with ¨sum" function : 
````Scheme
(define (sum s)
(if (null? s)
0
(+ (car s) (sum (cdr s)))))

(define (sum-tail s)
(sum-tail-helper s 0))

(define (sum-tail-helper s acc)
(if (null? s)
acc
(sum-tail-helper (cdr s) (+ (car s) acc))))
````

## Mapping and Folding


## Pairs

A _pair_ is a data struc­ture that holds two values. Once the pair is created, it cannot be changed (meaning, it is [immutable](https://beautifulracket.com/appendix/glossary.html#immutable)). A pair is made with [cons](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))). A pair is printed like a [list](https://beautifulracket.com/explainer/lists.html), but with a dot between the two values

`(cons 42 42)` is `'(42 . 42)`

`pair?` is the pred­i­cate func­tion.

Pairs can be combined to make other data struc­tures. For instance, under the hood, [lists](https://beautifulracket.com/explainer/lists.html) (other than the [empty](http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))) list) are made from a series of linked pairs, where the final element is [null](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._null))).

If you need to store two values, there’s nothing wrong with using a pair directly instead of a list. This can be worth­while in situ­a­tions that call for pecu­nious use of computing resources, because a two-element list uses two pairs rather than one (and thus twice as much memory and allo­ca­tion time). Keep in mind that because of this extra pair, the cdr of a list always returns a list, whereas in a pair it returns a single value

([cdr](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cdr))) ([cons](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))) 'this 'that)) ; 'that
([cdr](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cdr))) ([list](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))) 'this 'that)) ; '(that)

The names of cons, car, and cdr are conven­tional and historic. In the orig­inal Lisp inter­preter of 1958, cons was chosen as an abbre­vi­a­tion for “construct”. car and cdr were abbre­vi­a­tions for “contents of the address part of the register” and “contents of the decre­ment part of the register”, termi­nology specific to the IBM 704 computer that ran the inter­preter.


## Lists


In Racket, lists are unbounded, possibly heterogeneous collections (Racket lists can contain items of different types) of data.


madonna

````Scheme
> (list 1)
'(1)
````

pairs: https://beautifulracket.com/explainer/pairs.html


differenza tra list e vector ?

There are the concept of map, filter and also foldr and foldl. 
 

````Scheme
> (append '(1 2) '(2 1))
'(1 2 2 1)
```

> (append '(1 2) '(1))
'(1 2 1)
> (append '(1 2) 1)
'(1 2 . 1)

(cons 1 '(1 2))
'(1 1 2)

> (cons '(1 2) '(1 2))
'((1 2) 1 2)
````


car : gives back a single element
cdr: gives back a list 
append works very well between two lists

cons : 
```` Scheme
> (cons '(1) 2)
'((1) . 2)
> (cons 1 '(2 3))
'(1 2 3)
````


Never used eval because -> 

cons always create a cons node -> you must have an object and a list

append takes only 2 lists .


Lisp (di cui Scheme é un dialetto) deriva da LISt Processor La gestione delle liste é esattamente identica quella del lisp: sono trattate come coppie concatenate di due parti: • car (Content of the Address Register) a.k.a. first • cdr (Content of the Data Register) a.k.a. rest


https://www.tutorialspoint.com/execute_scheme_online.php

````Scheme
(define ( minimum L )
(let ((x ( car L ))
    (xs ( cdr L )))
(if (null? xs) ; is xs = ()?
x ; then return x
(minimum ; else : recursive call
(cons
(if (< x (car xs ))
x
(car xs ))
(cdr xs ))))))

(minimum '(110 63 52 43 43 42 54))
````

Here another way using ````apply```` . 

````Scheme
(define (minimum x . rest )  
  (if ( null ? rest ) ; is rest = ()? 
  x ; then return x 
  (apply minimum ; else : recursive call 
	  (cons (if (< x (car rest )) 
		  x 
		  (car rest )) 
		  ( cdr rest ))))) 
		  
		  (minimum 110 63 52 43 43 42 54)
````


````when```` is the same of ````if```` without the 'else' part . 
````Scheme
(let label (( x 0)) 
	  (when ( < x 10) 
	  (display x) 
	  (newline) 
	  (label (+ x 1)))) ; x++
````

Every Scheme implementation is required to be properly tail recursive A procedure is called tail recursive if its recursive call is "at the tail", i.e. is the last operation performed
````Scheme
(define ( fact-low-level-idiomatic n ) 
	  (let loop (( x n ) ( accum 1)) ( if (= x 0) accum ( loop (- x 1)(* x accum )))))````

but note that this looks like a tail call. . . (In reality, the named let is translated into a local recursive function. If tail recursive, when compiled it becomes a simple jump.)


vector-ref  , vector-length sono funzioni. 

semantics is very straight forward. The syntax is a little bit different from usual.


-   length -- length of a list
-   equal? -- test if two lists are equal (recursively)
````Scheme
- > (equal? '(1 2 3) '(1 2 3)) 
#t
> (equal? '(1 2 3) '(1 2 4)) 
#f
````
-   car -- first element of a list
-   cdr -- rest of a list
-   cons -- make a new _list cell_ (a.k.a. _cons cell_)


Evaluation strategy???

(for-each (lambda (x) (begin (display x) (newline))) l)


## Vectors 

Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time. The _length_ of a vector is the number of elements it contains. Vectors are indexed by exact nonnegative integers, and the index of the first element of any vector is 0. The highest valid index for a given vector is one less than its length.

As with lists, the elements of a vector can be of any type, and a single vector can hold more than one type of object.

A vector is written as a sequence of objects separated by whitespace, preceded by the prefix #( and followed by ). For example, a vector consisting of the elements a, b, and c would be written #(a b c).


## Predicates

are procedures that return boolean. 

- null?
- equal? 
- eq? (same objects?)
- equal?

the compilers rapresent the code as a tree structure.



## Continuations

A _contin­u­a­tion_ is a special kind of func­tion that’s like a snapshot of the current state of a running program. Contin­u­a­tions let you jump back to an **earlier** point in the computation, **circumventing the control flow** of the program. 
- When you invoke a contin­u­a­tion, it sends you back to the point in the program where the book­marked expres­sion was eval­u­ated. 
- The contin­u­a­tion takes one argu­ment, which replaces the value of the book­marked expres­sion. Eval­u­a­tion resumes from there.
- The fun part is when you treat the continuation as an object like others and for example, save it in a variable. In this way the variable contains "a point fixed" in the control flow of the program. 
- Continuations are also used as "glorified GOTO" since they permit to escape from cycles or bodies of procedures. 

`call/cc` is the keyword for continuations and it always takes a `lambda` function as argument. 

````Scheme
(+ 23 (call/cc (lambda (k) (+ 10 9)))) ;Risultato: 42

(+ 0 (call/cc (lambda (k) (+ 42 (k 42))))) ;Risultato: 42 poichè si esce subito da call/cc appena a k è stato assegnato un valore
````

This is a function which print until it finds a negative number, in this case the continuation is used as GOTO:

````Scheme
(define (print_until_neg l)
  (call/cc (lambda (exit) (for-each (lambda (x)
                (if (< x 0)
                    (exit)
                    (begin (display x) (newline))))l))))

>  (prova '(1 2 -3 4))
1
2
````

### Closures

As said before, continuations are used often as GOTO, but they are not interesting for this. The interesting thing to do with call/cc and continuations is using it to have **closures**. A closure is basically (explained in "spaghettata mode") a function with an environment, and we can write them using the ability of continuations to capture the state of its environment is what makes closures so powerful.
Closures are a fundamental concept in functional programming and are used for a variety of purposes, including creating function factories (functions that return functions), iterators and generators. 
Let's see a "generator" of Fibonacci sequence: 

````Scheme
(define fibo-stack #f)

(define (fibonacci-gen)
  (let ((last-fib 0) (fib 1) (x #f))
    (call/cc (lambda (fibo)
               (set! fibo-stack fibo))) ;assignment
    (set! x  (+ last-fib fib))
    (set! last-fib fib)
    (set! fib x)
    x))
````

`call/cc` allows us to "save the stack" by capturing the current continuation and storing it in `fibo-stack`. This captured continuation can then be invoked later, allowing us to jump back to the saved state.

````Scheme
> (fibonacci-gen)
1
> (fibo-stack)
2
> (fibo-stack)
3
> (fibo-stack)
5
> (fibo-stack)
8
> (fibo-stack)
13
> (fibo-stack)
21
````

At the line of `'assignment` comment I'm ¨saving" the computation exactly before the assignment of `last-fib` and `fib` . Every time that I call my continuation variable `fibo-stack` I obtain the next Fibonacci number (note that when I call `fibo-stack` I jump back inside the function and I perform the `set!` operations and, at the end, I'm giving back the variable `x` which contains the Fibonacci number).  

## Eval

In Scheme data and code are basically the same thing. Eval function evaluate something. If you pass with a Eval a list, Scheme will treat the list as passing arguments to Scheme interpreter itself. 

> (eval '(list 1))
'(1)


## Exceptions 

Exception handling is quite common in programming languages (see e.g. Java, where they are pervasive).
Recent Scheme standards have exception handling but we would like to implement *our*  throw / catch exception mechanism using continuations.

https://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/



## OOP Inheritance and structs 

It's not OOP but in some sense is similar 


In questa esercitazione ha fatto un esercizio abbastanza semplice sulle struct e sulla creazione di un albero binario (dovrei rifarlo come esercizio)

#:mutable usato per indicare quando un campo di una struct (quindi un oggetto) è mutabile. 


per accedere a un attributo di una struct basta usare - . 

(struct node node-base ;per indicare inheritance
  (left right))

remember list-ref to access n elements on a list
 

Inheritance in python is multi.
Java no. 

It is possible to use closures to do some basic OO programming
the main idea is to define a procedure which assumes the role of a class
this procedure, when called, returns a closure that works like an object
it works by implementing information hiding through the "enclosed" values of
the closure
access to the state is through messages to a function that works like a
dispatcher
Matteo
 

Indeed the main idea of OOP is something (an entity) that has both behaviour and d
-   A Set Cata.


You can also define new types through the use of structs. Structs are mixed between C structs and C++ classes. 


- Write struct and defining it. 
````Scheme
(struct node
  (left right))

> (define a (node 1 2))
````
- typeof: `(<struct>? <instance>)` to understand if a particular instance `<instance>` is of type `<struct_name>`
- getter: `(<struct>-<field> <instance>)`
````Scheme
> (node-left a)
1
````
- setter:  `(<struct>-<field>-set! <instance> <value>)` to set a value for a **mutable** field.
````Scheme
(struct leaf 
  ((value #:mutable)) ) ;making a mutable field 

> (define a (leaf 23))

> (display a)
#<leaf>

> (leaf-value a)
23

> (set-leaf-value! a 42) ;SETTER 
> (leaf-value a)
42
````


## Bibliography and references  


-   Scheme
    
    -   Implementation and documentation: [Racket](http://racket-lang.org/)
    -   [A good book on Scheme](http://www.scheme.com/tspl4/)
    -   [Standards](http://scheme-reports.org/)
    -   [For fans of macros](https://pradella.faculty.polimi.it/PL/syntax-rules-primer.txt) (§)

-   Other interesting stuff (§)
    
    -   [Lisp history](http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf)
    -   [Other historical Lisp stuff](http://www.softwarepreservation.org/projects/LISP/)
    -   [A. Colmerauer, P. Roussel, The birth of Prolog, 1992](http://www.google.it/url?sa=t&rct=j&q=history%20of%20prolog&source=web&cd=3&ved=0CEIQFjAC&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.85.7438%26rep%3Drep1%26type%3Dpdf&ei=_VoiT4CKNsGaOvuv9OQE&usg=AFQjCNG60HeXPPxFnluwlEQRVnWTVZBuBA&cad=rja)
    -   [L. Cardelli, Type Systems, The Computer Science and Engineering Handbook. CRC Press, Chapter 103, 1997](http://lucacardelli.name/Papers/TypeSystems%201st%20Edition.US.pdf)
    -   [R. P. Gabriel, Patterns of Software, 1996](http://dreamsongs.com/Files/PatternsOfSoftware.pdf), an inspiring book on Software, Design, Languages and Achitecture (both soft and _hard_!)
    -   [P. Hudak, Conception, evolution, and application of functional programming languages, ACM Comput. Surv. 21, 3, 1989](http://portal.acm.org/citation.cfm?doid=72551.72554)
    -   [J. Backus, Can Programming be Liberated from the von Neumann style?, CACM 21(8): 613-641, 1978](http://www.cs.cmu.edu/~crary/819-f09/Backus78.pdf)
    -   Fabrizio Ferrai's [Haskell is mainstream](https://pradella.faculty.polimi.it/PL/Haskell-mainstream.pdf)

 



## Addendum 

https://www.scheme.com/tspl4/ <- main
https://beautifulracket.com/ <- strange