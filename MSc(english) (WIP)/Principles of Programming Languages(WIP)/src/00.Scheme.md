# Scheme

## Main features

> "Scheme ... a lot of parentheses."

- Scheme dialect (which is in turn a language in the Lisp family) can be used in a **functional** style (but not purely functional)
- **Dynamically typed**: the type of a value is determined at runtime, rather than at compile-time. In dynamic typing, you don't have to specify the type of a variable when you declare it, and the type of the value stored in the variable can change dynamically during the execution of the program. (for example C++ is statically typed).
- **Functions are first class objects**; in this example I can pass any binary function to the function like any other object: 
````Scheme 
(define (fold binop n e)
  (if (<= n e)
      e
      (binop (fold binop (- n 1) e) n)))
````
- Scheme is **lexical scoped** like most programming languages (C, C++, and Java): the scope of a variable is determined by its location in the source code, more properly a variable always refers to its top-level environment. For example, if a variable is defined within a function, it will only be visible within that function and will not be accessible outside of it. This makes it easier to understand and manage the scope of variables in a program, because you can determine their visibility simply by looking at the source code. On the other hand, in dynamic scoping, the scope of a variable is determined by the order of function calls rather than its position in the source code.
- **Homoiconicity**: it means that there is no distinction between code and data and that for example statements, like expressions, are nestable.: `(+ 42 (if (< 1 0) 23 0))`. The `if` statement is nested inside the `+` expression and is treated as just another expression with a value.

## Variables

- Booleans: ````#t, #f````
- Numbers: ````42, 1.23e+33, 23/169, 12+4i````
- Characters: ````#a, #Z````
- Symbols: ````a-symbol, another-symbol?, indeed!````
- Vectors: ````#(1 2 3 4)```` 
- Strings: ````"this is a string"````
- Pair: `(x . y)` where the `car` is `x` and the `cdr` is `y` .  
- Lists: `'(1 2 3)` or `(quote (1 2 3))` or even `'(+ 1 2)'` 

## Quote and Eval

Note that in the last example `(quote )` is equivalent to `'` . In Scheme data and code are basically the same thing. The "inverse" of `(quote )` is `(eval )` . If you use `Eval` over a list for example, Scheme will treat the list as passing arguments to Scheme interpreter itself: `(eval quote(+ 1 2 3))` is 6. 

## Let

**Let** is not assignment, is creating a new variable. Let is used to bind variables. We say the variables are _bound_ to the values by the let.

```` Scheme
(let ( (<var> <expr>) (<var> <expr>) ... )
  <let body> 
)

//examples 

(let ((x 3) (y 2)) ;It's parallel 
  (+ x y)) ; 5 
)

(let* ((x 3) (y 2))  ; let* it's sequential
  (+ x y)) ; 5 
)
````

Variables created by let are local. To create top-level bindings there is  define:  
````Scheme
(define x 12)  
(define y #(1 2 3))
````

### Let* 

It's important to say that let binds in parallel while exists a variant of `let` where the assignments are sequential called `let*`. 

## Lambda Expressions

`lambda` is used to encapsulate piece of code inside the code, without the evaluation. You can use the `lambda` special form to create anonymous functions. Any lambda expression can be evaluated in any moment using `()`.

````Scheme
(lambda (<parameters>) <body> )

; here an example where I use "immediately" the lambda

> (display ((lambda (x y) (- x y))  2 3))
-1
````

`lambda` expression evaluates to an anonymous function that, when applied (executed), takes k arguments and returns the result of evaluating `expr`. As you would expect, the parameters are lexically scoped and can only be used in `expr`.

### Defining Named Functions

If you go to the trouble of defining a function, you often want to save it for later use. You accomplish this by binding the result of a `lambda` to a variable using `define`, just as you would with any other value.

````Scheme
(define (double x)
        (* 2 x))

(define (centigrade-to-fahrenheit c)
        (+ (* 1.8 c) 32.0))
````

````Scheme
(define (function x . rest)
  (displayln x)
  (display rest))

; notice how Scheme bounds the parameters 

> (function 1 2 3)
1 
(2 3)
````

In functions parameters are passed by values. So a function doesn´t change the value of the parameters. In these cases I should use a macro. 

````Scheme
(define (++ x)
	(set! x (+ x 1))
x)

>(define a 42)
>(++ a)
43

>a 
>42 
````

### Bang Procedures

In general, procedures with side effects have a trailing bang (!) character. For example `set!` is used for assignment. 

```scheme
(begin 
	(define x 23) 
	(set! x 42) 
	x)
```

is equals to `42`. 

## Begin and procedural code

We can perform sequence of operations (a block of procedural code) using `(begin ...)`:   

```scheme
(begin
	(op_1 ...)
	(op_2 ...)
	...
	(op_n ...))
```


## Macros

You could create new syntax with macros. Scheme has a very powerful Turing-complete macro system (note that Scheme is cool because you can define recursive macros). A macro is simply a text substitution of the body of the macro over the macro name.  

> You don't evaluate macros, you expand them. 

Macros are of course expanded at compile-time and they are defined in this way:

````Scheme
(define-syntax <rule_name> 
  (syntax-rules () ;variant of the rule name
  ((_ <first_parameter_here> <second_param> ...)
  <body_pattern_match>
  )))
````

In functions parameters are passed by values while in macros the parameters are passed by name. 

````Scheme
(define-syntax while
(syntax-rules () ; no other needed keywords
((_ condition body ...)    ; pattern 1  
(let loop () ; expansion of P
	(when condition
		(begin
		body ...
		(loop)))	
))))
````

Note that `_` is just a shorthand notation and `...` is a way to say that you can have multiple elements as body. 

### Hygiene of macros 

A macro could be expanded into a piece of code that contains a label that has the same name of a variable used by the user somewhere else. This would lead to a name clash. But in Scheme this **is not possible** since Scheme macros are hygienic: this means that symbols used in their definitions are actually replaced with special symbols not used anywhere else in the program.

## General loops 

Generally loops can be achieve using `let`: 

```scheme
(let (( x 0))
	(let label () 
	(when (< x 10)
		(display x)
		(newline )
		(set! x (+ 1 x ))
(label)))) ; go-to label
```

`(label)` is used to jump back at the start of the iteration body. 
But also remember that a loops can always be expressed as recursive functions: 

```scheme
(let label (( x 0))
	(when ( < x 10)
		(display x)
		(newline)
(label (+ x 1)))) ; x++
```


## Recursion

Recur­sion is a favored tech­nique in [func­tional program­ming](https://beautifulracket.com/appendix/glossary.html#functional-programming) because it helps avoid [muta­tion](https://beautifulracket.com/appendix/glossary.html#mutation) of values. The most important thing of recursion is **tail recur­sion**. A tail recursive function is one that returns the result of the recursive call back without alteration. Racket compilers handle tail recursion very efficiently, as efficiently as a program that just uses loops instead of recursion. 

````Scheme 
(define (fold op n e)
  (fold-helper op n e n))

(define (fold-helper op n e acc)
  (if (<= n e)
      acc
      (fold-helper op (- n 1) e (op acc (- n 1)))))

>(display (fold + 10 1))
> 55
>(+ 10 9 8 7 6 5 4 3 2 1)
````

The difference between a tail recursive function and a not tail recursive one is that at each time the operation is done **before** the recursion call: in this way "there are just calls of functions on the stack and not pending operations".
This is **NOT** tail recursive, since after the recursion it performs an multiplication:
```Scheme
(define (std-factorial n)
  (if (zero? n)
      1
      (* n (std-factorial (- n 1)))))
````
To turn this into a tail recursion function it's necessary an **accumulator**. This is a **typical pattern**: use an **helper function** with an additional parameter which accumulates the answer (the accumulator) to convert a non-tail recursive function into a tail recursive one. 
````Scheme
(define (factorial n)
  (acc-factorial n 1))

;; auxiliary function that takes an additional parameter (the accumulator,
;; i.e. the result computed so far)

(define (factorial n)
  (acc-factorial n 1))

;; auxiliary function that takes an additional parameter (the accumulator,
;; i.e. the result computed so far)
(define (acc-factorial n sofar)
  (if (zero? n)
      sofar
      (acc-factorial (- n 1) (* sofar n))))
````

Another example with "sum" function : 

````Scheme
(define (sum s)
(if (null? s)
0
(+ (car s) (sum (cdr s)))))

(define (sum-tail s)
(sum-tail-helper s 0))

(define (sum-tail-helper s acc)
(if (null? s)
acc
(sum-tail-helper (cdr s) (+ (car s) acc))))
````

## Mapping and Folding

## Pairs

A _pair_ is a data struc­ture that holds two values. Once the pair is created, it cannot be changed (meaning, it is [immutable](https://beautifulracket.com/appendix/glossary.html#immutable)). A pair is made with [cons](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))). A pair is printed like a [list](https://beautifulracket.com/explainer/lists.html), but with a dot between the two values

`(cons 42 42)` is `'(42 . 42)`

`pair?` is the pred­i­cate func­tion.

Pairs can be combined to make other data struc­tures. For instance, under the hood, [lists](https://beautifulracket.com/explainer/lists.html) (other than the [empty](http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))) list) are made from a series of linked pairs, where the final element is [null](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._null))).

If you need to store two values, there’s nothing wrong with using a pair directly instead of a list since a two-element list uses two pairs rather than one (and thus twice as much memory and allo­ca­tion time). Keep in mind that because of this extra pair, the cdr of a list always returns a list, whereas in a pair it returns a single value. 

The names of cons, car, and cdr are conven­tional and historic. In the orig­inal Lisp inter­preter of 1958, cons was chosen as an abbre­vi­a­tion for “construct”. `car` and `cdr` were abbre­vi­a­tions for “Contents of the Address part of the Register” and “Contents of the Decre­ment part of the Register”, termi­nology specific to the IBM 704 computer that ran the inter­preter.


## Lists

In Racket, lists are unbounded, possibly heterogeneous collections (Racket lists can contain items of different types) of data.

````Scheme
> (list 1)
'(1)
````


differenza tra list e vector ?

There are the concept of map, filter and also foldr and foldl. 

````Scheme
> (append '(1 2) '(2 1))
'(1 2 2 1)
```

> (append '(1 2) '(1))
'(1 2 1)
> (append '(1 2) 1)
'(1 2 . 1)

(cons 1 '(1 2))
'(1 1 2)

> (cons '(1 2) '(1 2))
'((1 2) 1 2)
````

append works very well between two lists

cons : 
```` Scheme
> (cons '(1) 2)
'((1) . 2)
> (cons 1 '(2 3))
'(1 2 3)
````


cons always create a cons node -> you must have an object and a list

append takes only 2 lists .

remember `list-ref` to access n elements on a list

Lisp (di cui Scheme é un dialetto) deriva da LISt Processor La gestione delle liste é esattamente identica quella del lisp: sono trattate come coppie concatenate di due parti: • car (Content of the Address Register) a.k.a. first • cdr (Content of the Data Register) a.k.a. rest


https://www.tutorialspoint.com/execute_scheme_online.php

````Scheme
(define (minimum L )
(let ((x ( car L ))
    (xs ( cdr L )))
(if (null? xs) ; is xs = ()?
x ; then return x
(minimum ; else : recursive call
(cons
(if (< x (car xs ))
x
(car xs ))
(cdr xs ))))))

(minimum '(110 63 52 43 43 42 54))
````

Here another way using ````apply```` . 

````Scheme
(define (minimum x . rest )  
  (if ( null ? rest ) ; is rest = ()? 
  x ; then return x 
  (apply minimum ; else : recursive call 
	  (cons (if (< x (car rest )) 
		  x 
		  (car rest )) 
		  ( cdr rest ))))) 
		  
		  (minimum 110 63 52 43 43 42 54)
````


````when```` is the same of ````if```` without the 'else' part . 
````Scheme
(let label (( x 0)) 
	  (when ( < x 10) 
	  (display x) 
	  (newline) 
	  (label (+ x 1)))) ; x++
````

Every Scheme implementation is required to be properly tail recursive A procedure is called tail recursive if its recursive call is "at the tail", i.e. is the last operation performed
````Scheme
(define ( fact-low-level-idiomatic n ) 
	  (let loop (( x n ) ( accum 1)) ( if (= x 0) accum ( loop (- x 1)(* x accum )))))````

but note that this looks like a tail call. . . (In reality, the named let is translated into a local recursive function. If tail recursive, when compiled it becomes a simple jump.)


vector-ref  , vector-length sono funzioni. 

semantics is very straight forward. The syntax is a little bit different from usual.


-   length -- length of a list
-   equal? -- test if two lists are equal (recursively)
````Scheme
- > (equal? '(1 2 3) '(1 2 3)) 
#t
> (equal? '(1 2 3) '(1 2 4)) 
#f
````
-   car -- first element of a list
-   cdr -- rest of a list
-   cons -- make a new _list cell_ (a.k.a. _cons cell_)


```scheme
(for-each (lambda (x) 
			(begin (display x) (newline))) 
my_list)
```




## Vectors 

Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time. The _length_ of a vector is the number of elements it contains. Vectors are indexed by exact nonnegative integers, and the index of the first element of any vector is 0. The highest valid index for a given vector is one less than its length.

As with lists, the elements of a vector can be of any type, and a single vector can hold more than one type of object.

A vector is written as a sequence of objects separated by whitespace, preceded by the prefix #( and followed by ). For example, a vector consisting of the elements a, b, and c would be written #(a b c).

It's possible to use `(vector-length vect_name)` `(vector-ref vect i)`



## Predicates

Predicates are procedures that returns boolean. 

- `null?` often used in loops to check if we are at the end of a list: `(if (null? rest ) ;is rest = ()?`
- `equal?` is `#t` iff the possibly infinite unfoldings of its arguments into regular trees are equal as ordered trees 
- `eq?` tests if two objects (all objects except numbers) are the same
- `eqv?` like `eq?` but also checks numbers

The compilers rapresent the code as a tree structure.


## Exceptions 

Exception handling is quite common in programming languages (see e.g. Java, where they are pervasive).
Recent Scheme standards have exception handling but we would like to implement *our*  throw / catch exception mechanism using continuations.

https://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/



## Continuations

A _contin­u­a­tion_ is a special kind of func­tion that’s like a snapshot of the current state of a running program. Contin­u­a­tions let you jump back to an **earlier** point in the computation, **circumventing the control flow** of the program. 
- When you invoke a contin­u­a­tion, it sends you back to the point in the program where the book­marked expres­sion was eval­u­ated. 
- The contin­u­a­tion takes one argu­ment, which replaces the value of the book­marked expres­sion. Eval­u­a­tion resumes from there.
- The fun part is when you treat the continuation as an object like others and for example, **save it in a variable**. In this way the variable contains "a fixed point" in the control flow of the program. 
- Continuations are also used as "glorified GOTO" since they permit to escape from cycles or bodies of procedures. 

`call/cc` is the keyword for continuations and it always takes a `lambda` function as argument. 

````Scheme
(+ 23 (call/cc (lambda (k) (+ 10 9)))) ;Risultato: 42

(+ 11 (call/cc (lambda (k) (+ 42 (k 31))))) ;Risultato: 42 poichè si esce subito da call/cc appena a k è stato assegnato un valore
````

This is a function which print until it finds a negative number, in this case the continuation is used as **GOTO**:

````Scheme
(define (print_until_neg l)
  (call/cc (lambda (exit) (for-each (lambda (x)
                (if (< x 0)
                    (exit)
                    (begin (display x) (newline))))l))))

>  (prova '(1 2 -3 4))
1
2
````

### Closures

## Capire ( define ( iter-vector vec ) dalle slides
## anche " interlude on some classical higher order functions  " 

The interesting thing to do with call/cc and continuations is using it to have **closures**. A closure is basically (explained in "spaghettata mode") a function with an environment, and we can write it using the ability of continuations to capture the state of its environment.
Closures are a fundamental concept in functional programming and are used for a variety of purposes, including creating function factories (functions that return functions), iterators and generators. 
Let's see a "generator" of Fibonacci sequence: 

````Scheme
(define fibo-stack #f)

(define (fibonacci-gen)
  (let ((last-fib 0) (fib 1) (x #f))
    (call/cc (lambda (fibo)
               (set! fibo-stack fibo))) ;assignment
    (set! x  (+ last-fib fib))
    (set! last-fib fib)
    (set! fib x)
    x))
````

`call/cc` allows us to "save the stack" by capturing the current continuation and storing it in `fibo-stack`. This captured continuation can then be invoked later, allowing us to jump back to the saved state.

````Scheme
> (fibonacci-gen)
1
> (fibo-stack)
2
> (fibo-stack)
3
> (fibo-stack)
5
> (fibo-stack)
8
> (fibo-stack)
13
> (fibo-stack)
21
````

At the line of `'assignment` comment I'm "saving" the computation exactly before the assignment of `last-fib` and `fib` . Every time that I call my continuation variable `fibo-stack` I obtain the next Fibonacci number (note that when I call `fibo-stack` I jump back inside the function and I perform the `set!` operations and, at the end, I'm giving back the variable `x` which contains the Fibonacci number).  

## Structs 

New types can be defined with `struct` similar to C, but with some differences. Related procedures such as `struct_name` constructor and a predicate to check the type of the new object are automatically created.

```scheme
(struct node node-base ;inheritance
  (left right))
```

- typeof: `(<struct>? <instance>)` to understand if a particular instance `<instance>` is of type `<struct_name>`
- getter: `(<struct>-<field> <instance>)`

````Scheme
(struct node
  (left right))

> (define a (node 1 2))
````


Structs can inherit: 

````Scheme
(struct node node-base ;inheritance
  (left right))
````

- setter:  `(<struct>-<field>-set! <instance> <value>)` to set a value for a **mutable** field.

````Scheme
(struct leaf 
  ((value #:mutable)) ) ;making a mutable field 

> (define a (leaf 23))

> (display a)
#<leaf>

> (leaf-value a)
23

> (set-leaf-value! a 42) ;SETTER 
> (leaf-value a)
42
````


## Bibliography and references  


-   Scheme
    
    -   Implementation and documentation: [Racket](http://racket-lang.org/)
    -   [A good book on Scheme](http://www.scheme.com/tspl4/)
    -   [Standards](http://scheme-reports.org/)
    -   [For fans of macros](https://pradella.faculty.polimi.it/PL/syntax-rules-primer.txt) (§)

-   Other interesting stuff (§)
    
    -   [Lisp history](http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf)
    -   [Other historical Lisp stuff](http://www.softwarepreservation.org/projects/LISP/)
    -   [A. Colmerauer, P. Roussel, The birth of Prolog, 1992](http://www.google.it/url?sa=t&rct=j&q=history%20of%20prolog&source=web&cd=3&ved=0CEIQFjAC&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.85.7438%26rep%3Drep1%26type%3Dpdf&ei=_VoiT4CKNsGaOvuv9OQE&usg=AFQjCNG60HeXPPxFnluwlEQRVnWTVZBuBA&cad=rja)
    -   [L. Cardelli, Type Systems, The Computer Science and Engineering Handbook. CRC Press, Chapter 103, 1997](http://lucacardelli.name/Papers/TypeSystems%201st%20Edition.US.pdf)
    -   [R. P. Gabriel, Patterns of Software, 1996](http://dreamsongs.com/Files/PatternsOfSoftware.pdf), an inspiring book on Software, Design, Languages and Achitecture (both soft and _hard_!)
    -   [P. Hudak, Conception, evolution, and application of functional programming languages, ACM Comput. Surv. 21, 3, 1989](http://portal.acm.org/citation.cfm?doid=72551.72554)
    -   [J. Backus, Can Programming be Liberated from the von Neumann style?, CACM 21(8): 613-641, 1978](http://www.cs.cmu.edu/~crary/819-f09/Backus78.pdf)
    -   Fabrizio Ferrai's [Haskell is mainstream](https://pradella.faculty.polimi.it/PL/Haskell-mainstream.pdf)



## Addendum 

https://www.scheme.com/tspl4/ <- main
https://beautifulracket.com/ <- strange



check what is delay and promise in Haskell slides 