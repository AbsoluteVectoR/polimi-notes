
# Scheme

State­ments and expres­sions are distinct because while expres­sions can be natu­rally nested with each other, state­ments and expres­sions cannot.
By making every­thing an expres­sion, however, Lisps remove this limi­ta­tion. Since expres­sions are nestable, anything in the language can be combined with nearly anything else.
` (+ 42 (if (< 1 0) 23 0))`

`(+ (< 1 0) + *) 42 100)`

As a programmer, this simpli­fies your work, because every­thing snaps together easily. It also expands your possi­bil­i­ties, because you can combine parts of the language in unusual ways if you feel like it.



## Basics

Scheme is a little bit strange because the structure of the program is given by its syntax itself.
Scheme -> quite ancient! -> not to write stuff but to write new stuff. Scheme is cool to thinking about new constructs and a new language. This course is for becoming 'flexible' . After this course you will learn any languages very easily. 


-   Scheme dialect (which is in turn a language in the Lisp family)
-   can be used in a functional style (but not purely functional)
-   dynamic typing; type safe

- lexically scoped (originally Lisp used dynamic scoping)

In lexically scoped programming languages, the scope of a variable is determined by its location in the source code. For example, if a variable is defined within a function, it will only be visible within that function and will not be accessible outside of it. This makes it easier to understand and manage the scope of variables in a program, because you can determine their visibility simply by looking at the source code.
(probably) 
Dynamic scoping is an alternative to lexical scoping, where the scope of a variable is determined by the order of function calls rather than its position in the source code.



Scheme ... a lot of Parentesys. 
- Booleans: ````#t, #f````
- Numbers: ````132897132989731289713, 1.23e+33, 23/169, 12+4i````
- Characters: ````#a, #Z````
- Symbols: ````a-symbol, another-symbol?, indeed!````
- Vectors: ````#( 1  2 3 4)```` 
- Strings: ````"this is a string"````
- Pairs and Lists: ````(1 2 #\a), (a . b),()````

Scheme is mainly functional language: every program is an expression and computation is based on evaluating expressions. 
!!!! The evaluation order of parameters is unspecified: Scheme doesn't make left-to-right evaluation like humans. 




In Racket, lists are unbounded, possibly heterogeneous collections (Racket lists can contain items of different types) of data.


first-class functions

Functional -> Functions are first class objects. 

````Scheme 
(define (fold binop n e)
  (if (<= n e)
      e
      (binop (fold binop (- n 1) e) n)))
````

in this example I can pass any binary function to the function. 

###  Evaluating Scheme Expressions
###  Variables and Let Expressions



## Lambda Expressions


Closures is essentially a function but with a referencing environment. It's a closure if the definition is based on variables that are stored in the 'environment of the function'. 
In some sense a closure is not just a behavour (like a lambda function) but it's something more: data. 
A simple and immediate application of a closure is the 'iterator'! 

Lambda function + static environment with variables that are closed by the closure is very similar to OOP ! 

concept of evaluation 

lambda is used to encapsulate piece of code inside the code, without the evaluation. 
It can be evaluated in any moment using '()' .

-   Case-Lambda
-   Local Binding
-   Multiple Values
-   Variable Definitions
-   Assignment


You can use the `lambda` special form to create anonymous functions. This special form takes

(lambda (param1 param2 ... paramk)  ; list of formals
        expr)                       ; body

`lambda` expression evaluates to an anonymous function that, when applied (executed), takes k arguments and returns the result of evaluating `expr`. As you would expect, the parameters are lexically scoped and can only be used in `expr`.

### Defining Named Functions

````Scheme
(define (function x . rest)
  (displayln x)
  (display rest))

; notice how Scheme bounds the parameters 

> (function 1 2 3)
1 
(2 3)
````



If you go to the trouble of defining a function, you often want to save it for later use. You accomplish this by binding the result of a `lambda` to a variable using `define`, just as you would with any other value.

````Scheme
(define (double x)
        (* 2 x))

(define (centigrade-to-fahrenheit c)
        (+ (* 1.8 c) 32.0))
````


Static vs Dynamic scoping


The **scope** of a variable x in the region of the program in which the use of x refers to its declaration. One of the basic reasons for scoping is to keep variables in different parts of the program distinct from one another. Since there are only a small number of short variable names, and programmers share habits about naming of variables (e.g., I for an array index), in any program of moderate size the same variable name will be used in multiple different scopes.  
Scoping is generally divided into two classes:   
**1.** Static Scoping   
**2.** Dynamic Scoping  



**Static Scoping:**   
Static scoping is also called **lexical scoping**. In this scoping, a variable always refers to its top-level environment. This is a property of the program text and is unrelated to the run-time call stack. Static scoping also makes it much easier to make a modular code as a programmer can figure out the scope just by looking at the code. In contrast, dynamic scope requires the programmer to anticipate all possible dynamic contexts.  
In most programming languages including C, C++, and Java, variables are always statically (or lexically) scoped i.e., binding of a variable can be determined by program text and is independent of the run-time function call stack.   
For example, the output for the below program is 10, i.e., the value returned by f() is not dependent on who is calling it (Like g() calls it and has a x with value 20). f() always returns the value of global variable x.

To sum up, in static scoping the compiler first searches in the current block, then in global variables, then in successively smaller scopes.  

**Dynamic Scoping:**   
The main idea is that in any moment of the software to know which value a variable is assigned to you have to 'look into the stack' or in some way run it. While the static scoping is (as the name is telling) static. 
With dynamic scope, a global identifier refers to the identifier associated with the most recent environment and is uncommon in modern languages. In technical terms, this means that each identifier has a global stack of bindings and the occurrence of an identifier is searched in the most recent binding.   
In simpler terms, in dynamic scoping, the compiler first searches the current block and then successively all the calling functions.


Let is not assignment, is creating a new variable. Let is used to bind variables.

```` Scheme
(let ( (<var> <expr>) (<var> <expr>) ... )
  <let body> 
)

//examples 

(let ((x 3) (y 2)) ;It's parallel 
  (+ x y)) ; 5 
)

(let* ((x 3) (y 2))  ; let* it's sequential
  (+ x y)) ; 5 
)
````

Variables created by let are local. To create top-level bindings there is  
define:  
````Scheme
(define x 12)  
(define y #(1 2 3))
````


NB: in general, procedures with side effects have a trailing bang (!) character.

We say the variables are _bound_ to the values by the let.

Lambdas are unnamed procedures 

````Scheme
(lambda (<parameters>) <body> )

; here an example where I use "immediately" the lambda

> (display ((lambda (x y) (- x y))  2 3))
-1
````


### Homoiconicity

It means that there is no distinction between code and data, as in von Neumann's architectural code This could be complicated, but very effective for meta-programming purposes Since code is very much a given, it is very easy to design code which creates and composes other code.


Woow it is possible to create syntax using the language. Let and Lambda are just symbol used by the syntax but you, using macros could create new syntax. 


Modello di storage Le variabili e gli oggetti sono riferiti implicitamente a locazioni presenti nella memoria heap


!!!! 

Sequence of operations: begin  
If we are writing a block of procedural code, we can use the begin construct



## While and macros


A macro can be even recursively. 

A macro is simply a text substitution of the body of the macro over the macro name.  

> You don't evaluate macros, you expand them. 

Scheme has a very powerful Turing-complete macro system. 
Macros are of course expanded at compile-time 3 macros are defined through define-syntax and syntax-rules. 
````Scheme
(define-syntax <rule_name> 
  (syntax-rules () ;variant of the rule name
  ((_ <first_parameter_here> <second_param> ...)
  <body_pattern_match>
  )))
````

In functions parameters are passed by values while in macros the parameters are passed by name. In C for example the parameters are passed by value. In Java the parameters are passed by reference. 

````Scheme

(define (++ x)
	(set! x (+ x 1))
x)


>(define a 42)
>(++ a)
43

>a 
>42 
````

So a function doesn´t change the value of the parameters. In these cases I should use a macro. 

````Scheme
(define-syntax while
(syntax-rules () ; no other needed keywords
((_ parameter ...)    ; pattern 1  
(let loop () ; expansion of P
	(when condition
		(begin
		body ...
		(loop)))
		
((_ parameter ...)    ; pattern 2 
(let loop2 () ; expansion of P
	(when condition
		(begin
		body ...
		(loop2)))
		
))))
````

Note that _ is just a shorthand notation and "..." is a way to say that you can have multiple elements as body. Note that Scheme is cool because you can define recursive macros. 


Macros allows us to expand the syntax 

### Hygiene of macros 

Scheme macros are hygienic: this means that symbols used in their definitions are actually replaced with special symbols not used anywhere else in the program. In this way it's impossible to have name clashes when the macro is expanded. For example a macro could be expanded into a piece of code that contains a label that has the same name of a variable used by the user for example -> so the name clash. 


e.g. without hygene the following code
( define ( fact-with-while n)
(let ((x n)( loop 1))
( while (> x 0)
(set! loop (* x loop ))
(set! x (- x 1)))
loop ))
would be expanded into:
( define ( fact-with-while n)
(let ((x n)( loop 1))
(let loop ()
( when (> x 0)
(set! loop (* x loop ))
(set! x (- x 1))
( loop )))
loop ))




The expression \#t defines as true, while \#f defines as false. In addition to any other
Something different \#f is considered true with respect to conditional forms such as if, and, or or Cond.


Macros are expendaded at compile time!!! Not all the parameters are completely evaluated at compile time! The most of them just copied.


the dots ... in the macros definitions are a way of extracting just specific parameters from the functions. 

## Procedure Application

-   Sequencing
-   Conditionals


## Recursion and iteration


### [Why is recur­sion impor­tant?](https://beautifulracket.com/explainer/recursion.html#why-is-recursion-important)



Recur­sion is a favored tech­nique in [func­tional program­ming](https://beautifulracket.com/appendix/glossary.html#functional-programming) because it helps avoid [muta­tion](https://beautifulracket.com/appendix/glossary.html#mutation) of values. The first version of our factorial func­tion mutated the vari­able product on each pass. The second did not.



Further­more, because so many data struc­tures in func­tional languages are defined recur­sively—like [lists](https://beautifulracket.com/explainer/lists.html)—recur­sive func­tions end up being the most natural way to work with them.

Here, we use first and rest to break the task into smaller versions of the same task. Then we test the input for null? as our termi­nating condi­tion.



### [Tail recur­sion](https://beautifulracket.com/explainer/recursion.html#tail-recursion)



_Tail recur­sion_ refers to the special case where the return value of the recur­sive branch is nothing more than the value of the next recur­sive call (also known as a _tail call_).

The last function is not stack efficient since is not tail-recursive. Tail recursion is an important concept... in this example on the stack of the VM which runs Scheme ¨there all the operations that are waiting for the recursive call. 

````Scheme 
(define (fold op n e)
  (fold-helper op n e n))

(define (fold-helper op n e acc)
  (if (<= n e)
      acc
      (fold-helper op (- n 1) e (op acc (- n 1)))))

>(display (fold + 10 1))
> 55
>(+ 10 9 8 7 6 5 4 3 2 1)
````

The difference is that at each time the operation is done **before** the recursion call: in this way there are just ¨calls of functions on the stack and not pending operations¨ 


A tail recursive function is one that returns the result of the recursive call back without alteration. (So unlike a function like append, we don't build up a solution as the recursion unwinds.)

Racket compilers handle tail recursion very efficiently, as efficiently as a program that just uses loops instead of recursion. (In particular, tail recursive functions don't use stack space for every recursive call.)

Sometimes you can use an _accumulator_ -- an additional parameter to a function that accumulates the answer -- to convert a non-tail recursive function into a tail recursive one. For example, the usual definition for factorial isn't tail-recursive:

(define (std-factorial n)
  (if (zero? n)
      1
      (* n (std-factorial (- n 1)))))

Here is a version that is tail recursive:

(define (factorial n)
  (acc-factorial n 1))


;; auxiliary function that takes an additional parameter (the accumulator,
;; i.e. the result computed so far)

(define (factorial n)
  (acc-factorial n 1))


;; auxiliary function that takes an additional parameter (the accumulator,
;; i.e. the result computed so far)
(define (acc-factorial n sofar)
  (if (zero? n)
      sofar
      (acc-factorial (- n 1) (* sofar n))))


````Scheme
(define (sum s)
(if (null? s)
0
(+ (car s) (sum (cdr s)))))

(define (sum-tail s)
(sum-tail-helper s 0))

(define (sum-tail-helper s acc)
(if (null? s)
acc
(sum-tail-helper (cdr s) (+ (car s) acc))))
````

## Mapping and Folding


## Continuations

A _contin­u­a­tion_ is a special kind of func­tion that’s like a book­mark to the loca­tion of an expres­sion. Contin­u­a­tions let you jump back to an earlier point in the program, thereby circum­venting the [control flow](https://beautifulracket.com/appendix/glossary.html#control-flow) of the usual [eval­u­a­tion](https://beautifulracket.com/explainer/evaluation.html) model. Like [macros](https://beautifulracket.com/explainer/macros.html), they’re not a tool of first resort. But they have a niche.


When you invoke a contin­u­a­tion, it sends you back to the point in the program where the book­marked expres­sion was eval­u­ated. The contin­u­a­tion takes one argu­ment, which replaces the value of the book­marked expres­sion. Eval­u­a­tion resumes from there.


https://beautifulracket.com/explainer/continuations.html

A continuation is a data structure used to represent the state of a running program. 

call/cc always takes a lambda function as argument. 

The argument of call/cc is also called an escape procedure: basically we save/restore  the 'call stack'.
When a continuation object is applied to an argument, the existing continuation is eliminated and the applied continuation is restored in its place, so that the program flow will continue at the point at which the continuation was captured and _the argument of the continuation_ then becomes the "return value" of the call/cc invocation. 

How continuations are implemented? We consider here two approaches (there are many variants):

- the garbage-collection strategy (slower)
- the stack strategy 

````Scheme
(+ 23 (call/cc (lambda (k) (+ 10 9)))) ;Risultato: 42

(+ 0 (call/cc (lambda (k) (+ 42 (k 42))))) ;Risultato: 42 poichè si esce subito da call/cc appena a k è stato assegnato un valore
````

````Scheme
(define (prova l)
  (call/cc (lambda (exit) (for-each (lambda (x)
                (if (< x 0)
                    (exit)
                    (begin (display x) (newline))))l))))

>  (prova '(1 2 -3 4))
1
2
````

Un uso comune della call/cc é per le uscite strutturate non locali da cicli o da corpi di procedure, ma in realtá la call/cc é molto utile anche per implementare strutture di controllo molto piú complesse, come gli iteratori.
Le continuazioni sono molto potenti, ma rendono difficile capire qual’é il flusso del programma: spesso vengono definite GOTO glorificati.


esercitazione del 19 di Scheme 'tosta' sulle continuations 


capita in parte

INTERESTING: last exercise is about storing continuations in a stack


-   Continuation Passing Style


Interesting use of continuations to implement a non deterministic function. <- probably the most difficult thing in all  the course. 


call/cc is like goto but it's not very interesting. The interesting thing to do with call/cc and continuations is using it to have closures in scheme. A closure in function with an environment. To do this with continuations we basically call/cc to "save the stack" . 

A closure in Scheme is a first-class function value that has access to the variables in its enclosing scope, even after the scope has exited. This ability to capture the state of its environment is what makes closures so powerful.

When a closure is created, it captures the values of its free variables at the time of its creation. When the closure is later invoked, it uses these captured values, allowing it to maintain state even after its enclosing scope has exited. This ability to capture state is what makes closures so useful in functional programming.

To create a closure with an environment, we can use the call/cc (call with current continuation) function. The call/cc function allows us to "save the stack" by capturing the current continuation and storing it in a variable. This captured continuation can then be invoked later, allowing us to jump back to the saved state.

The theory behind closures is rooted in lambda calculus, which is the mathematical theory behind functional programming. Closures are a fundamental concept in functional programming and are used for a variety of purposes, including creating function factories (functions that return functions), implementing continuations, and more.



One similarity is that both closures and generators provide a way to maintain state across invocations.


Closures, on the other hand, provide a way to capture state and maintain it across invocations

Let's see a "generator" of Fibonacci sequence: 

````Scheme
(define fibo-stack #f)

(define (fibonacci-gen)
  (let ((last-fib 0) (fib 1) (x #f))
    (call/cc (lambda (fibo)
               (set! fibo-stack fibo))) ;assignment
    (set! x  (+ last-fib fib))
    (set! last-fib fib)
    (set! fib x)
    x))
````

At the line of `'assignment` I'm ¨saving" the computation exactly before the assignment of `last-fib` and `fib` . Every time that I call my continuation variable `fibo-stack` I obtain the next Fibonacci number. 

````Scheme
> (fibonacci-gen)
1
> (fibo-stack)
2
> (fibo-stack)
3
> (fibo-stack)
5
> (fibo-stack)
8
> (fibo-stack)
13
> (fibo-stack)
21
````



## Delayed Evaluation

## Multiple Values

## Eval

In Scheme data and code are basically the same thing. Eval function evaluate something. If you pass with a Eval a list, Scheme will treat the list as passing arguments to Scheme interpreter itself. 

> (eval '(list 1))
'(1)




## Exceptions 

Exception handling is quite common in programming languages (see e.g. Java, where they are pervasive).
Recent Scheme standards have exception handling but we would like to implement *our*  throw / catch exception mechanism using continuations.

https://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/


## Pairs

A _pair_ is a data struc­ture that holds two values. Once the pair is created, it cannot be changed (meaning, it is [immutable](https://beautifulracket.com/appendix/glossary.html#immutable)). A pair is made with [cons](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))). A pair is printed like a [list](https://beautifulracket.com/explainer/lists.html), but with a dot between the two values

`(cons 42 42)` is `'(42 . 42)`

`pair?` is the pred­i­cate func­tion.

Pairs can be combined to make other data struc­tures. For instance, under the hood, [lists](https://beautifulracket.com/explainer/lists.html) (other than the [empty](http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._empty))) list) are made from a series of linked pairs, where the final element is [null](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._null))).

If you need to store two values, there’s nothing wrong with using a pair directly instead of a list. This can be worth­while in situ­a­tions that call for pecu­nious use of computing resources, because a two-element list uses two pairs rather than one (and thus twice as much memory and allo­ca­tion time). Keep in mind that because of this extra pair, the cdr of a list always returns a list, whereas in a pair it returns a single value

([cdr](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cdr))) ([cons](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))) 'this 'that)) ; 'that
([cdr](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cdr))) ([list](http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))) 'this 'that)) ; '(that)

The names of cons, car, and cdr are conven­tional and historic. In the orig­inal Lisp inter­preter of 1958, cons was chosen as an abbre­vi­a­tion for “construct”. car and cdr were abbre­vi­a­tions for “contents of the address part of the register” and “contents of the decre­ment part of the register”, termi­nology specific to the IBM 704 computer that ran the inter­preter.


## Lists

madonna

````Scheme
> (list 1)
'(1)
````

pairs: https://beautifulracket.com/explainer/pairs.html


differenza tra list e vector ?

There are the concept of map, filter and also foldr and foldl. 
 

````Scheme
> (append '(1 2) '(2 1))
'(1 2 2 1)
```

> (append '(1 2) '(1))
'(1 2 1)
> (append '(1 2) 1)
'(1 2 . 1)

(cons 1 '(1 2))
'(1 1 2)

> (cons '(1 2) '(1 2))
'((1 2) 1 2)
````


car : gives back a single element
cdr: gives back a list 
append works very well between two lists

cons : 
```` Scheme
> (cons '(1) 2)
'((1) . 2)
> (cons 1 '(2 3))
'(1 2 3)
````


Never used eval because -> 

cons always create a cons node -> you must have an object and a list

append takes only 2 lists .


Lisp (di cui Scheme é un dialetto) deriva da LISt Processor La gestione delle liste é esattamente identica quella del lisp: sono trattate come coppie concatenate di due parti: • car (Content of the Address Register) a.k.a. first • cdr (Content of the Data Register) a.k.a. rest


https://www.tutorialspoint.com/execute_scheme_online.php

````Scheme
(define ( minimum L )
(let ((x ( car L ))
    (xs ( cdr L )))
(if (null? xs) ; is xs = ()?
x ; then return x
(minimum ; else : recursive call
(cons
(if (< x (car xs ))
x
(car xs ))
(cdr xs ))))))

(minimum '(110 63 52 43 43 42 54))
````

Here another way using ````apply```` . 

````Scheme
(define (minimum x . rest )  
  (if ( null ? rest ) ; is rest = ()? 
  x ; then return x 
  (apply minimum ; else : recursive call 
	  (cons (if (< x (car rest )) 
		  x 
		  (car rest )) 
		  ( cdr rest ))))) 
		  
		  (minimum 110 63 52 43 43 42 54)
````


````when```` is the same of ````if```` without the 'else' part . 
````Scheme
(let label (( x 0)) 
	  (when ( < x 10) 
	  (display x) 
	  (newline) 
	  (label (+ x 1)))) ; x++
````

Every Scheme implementation is required to be properly tail recursive A procedure is called tail recursive if its recursive call is "at the tail", i.e. is the last operation performed
````Scheme
(define ( fact-low-level-idiomatic n ) 
	  (let loop (( x n ) ( accum 1)) ( if (= x 0) accum ( loop (- x 1)(* x accum )))))````

but note that this looks like a tail call. . . (In reality, the named let is translated into a local recursive function. If tail recursive, when compiled it becomes a simple jump.)


vector-ref  , vector-length sono funzioni. 

semantics is very straight forward. The syntax is a little bit different from usual.


-   length -- length of a list
-   equal? -- test if two lists are equal (recursively)
````Scheme
- > (equal? '(1 2 3) '(1 2 3)) 
#t
> (equal? '(1 2 3) '(1 2 4)) 
#f
````
-   car -- first element of a list
-   cdr -- rest of a list
-   cons -- make a new _list cell_ (a.k.a. _cons cell_)


Evaluation strategy???

(for-each (lambda (x) (begin (display x) (newline))) l)


## Vectors 

Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time. The _length_ of a vector is the number of elements it contains. Vectors are indexed by exact nonnegative integers, and the index of the first element of any vector is 0. The highest valid index for a given vector is one less than its length.

As with lists, the elements of a vector can be of any type, and a single vector can hold more than one type of object.

A vector is written as a sequence of objects separated by whitespace, preceded by the prefix #( and followed by ). For example, a vector consisting of the elements a, b, and c would be written #(a b c).

**procedure**: (vector _obj_ ...)  
**returns:** a vector of the objects _obj_ ...  
**libraries:** (rnrs base), (rnrs)

(vector) ![<graphic>](https://www.scheme.com/tspl4/math/tspl/0.gif) #()  
(vector 'a 'b 'c) ![<graphic>](https://www.scheme.com/tspl4/math/tspl/0.gif) #(a b c)

## Predicates

are procedures that return boolean. 

- null?
- equal? 
- eq? (same objects?)
- equal?

the compilers rapresent the code as a tree structure.



## OOP Inheritance and structs 

It's not OOP but in some sense is similar 


In questa esercitazione ha fatto un esercizio abbastanza semplice sulle struct e sulla creazione di un albero binario (dovrei rifarlo come esercizio)

#:mutable usato per indicare quando un campo di una struct (quindi un oggetto) è mutabile. 


per accedere a un attributo di una struct basta usare - . 

(struct node node-base ;per indicare inheritance
  (left right))

remember list-ref to access n elements on a list
 

Inheritance in python is multi.
Java no. 

It is possible to use closures to do some basic OO programming
the main idea is to define a procedure which assumes the role of a class
this procedure, when called, returns a closure that works like an object
it works by implementing information hiding through the "enclosed" values of
the closure
access to the state is through messages to a function that works like a
dispatcher
Matteo
 

Indeed the main idea of OOP is something (an entity) that has both behaviour and data.


You can also define new types through the use of structs. Structs are mixed between C structs and C++ classes. 


- Write struct and defining it. 
````Scheme
(struct node
  (left right))

> (define a (node 1 2))
````
- typeof: `(<struct>? <instance>)` to understand if a particular instance `<instance>` is of type `<struct_name>`
- getter: `(<struct>-<field> <instance>)`
````Scheme
> (node-left a)
1
````
- setter:  `(<struct>-<field>-set! <instance> <value>)` to set a value for a **mutable** field.
````Scheme
(struct leaf 
  ((value #:mutable)) ) ;making a mutable field 

> (define a (leaf 23))

> (display a)
#<leaf>

> (leaf-value a)
23

> (set-leaf-value! a 42) ;SETTER 
> (leaf-value a)
42
````



## Extended Examples

-   Matrix and Vector Multiplication
-   Sorting
-   A Set Constructor
-   Word Frequency Counting
-   Scheme Printer
-   Formatted Output
-   A Meta-Circular Interpreter for Scheme
-   Defining Abstract Objects
-   Fast Fourier Transform
-   A Unification Algorithm
-   Multitasking with Engines


## Bibliography and references  


-   Scheme
    
    -   Implementation and documentation: [Racket](http://racket-lang.org/)
    -   [A good book on Scheme](http://www.scheme.com/tspl4/)
    -   [Standards](http://scheme-reports.org/)
    -   [For fans of macros](https://pradella.faculty.polimi.it/PL/syntax-rules-primer.txt) (§)

-   Other interesting stuff (§)
    
    -   [Lisp history](http://www.dreamsongs.com/Files/HOPL2-Uncut.pdf)
    -   [Other historical Lisp stuff](http://www.softwarepreservation.org/projects/LISP/)
    -   [A. Colmerauer, P. Roussel, The birth of Prolog, 1992](http://www.google.it/url?sa=t&rct=j&q=history%20of%20prolog&source=web&cd=3&ved=0CEIQFjAC&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.85.7438%26rep%3Drep1%26type%3Dpdf&ei=_VoiT4CKNsGaOvuv9OQE&usg=AFQjCNG60HeXPPxFnluwlEQRVnWTVZBuBA&cad=rja)
    -   [L. Cardelli, Type Systems, The Computer Science and Engineering Handbook. CRC Press, Chapter 103, 1997](http://lucacardelli.name/Papers/TypeSystems%201st%20Edition.US.pdf)
    -   [R. P. Gabriel, Patterns of Software, 1996](http://dreamsongs.com/Files/PatternsOfSoftware.pdf), an inspiring book on Software, Design, Languages and Achitecture (both soft and _hard_!)
    -   [P. Hudak, Conception, evolution, and application of functional programming languages, ACM Comput. Surv. 21, 3, 1989](http://portal.acm.org/citation.cfm?doid=72551.72554)
    -   [J. Backus, Can Programming be Liberated from the von Neumann style?, CACM 21(8): 613-641, 1978](http://www.cs.cmu.edu/~crary/819-f09/Backus78.pdf)
    -   Fabrizio Ferrai's [Haskell is mainstream](https://pradella.faculty.polimi.it/PL/Haskell-mainstream.pdf)

 



## Addendum 

https://www.scheme.com/tspl4/ <- main
https://beautifulracket.com/ <- strange