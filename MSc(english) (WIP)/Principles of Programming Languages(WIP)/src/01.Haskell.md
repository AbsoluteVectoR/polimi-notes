
# Haskell 

## Introduction

Haskell is a **functional** programming language that emphasizes **purity** and **lazy** evaluation. In order to understand how Haskell works, it's important to first understand the concepts of **function evaluation** and **termination**. 

Born in 1990, Haskell is a functional programming language designed by a committee of experts to embody the following characteristics:

1. **Purely Functional**: Haskell is a purely functional language, meaning that all computations are performed using functions and function application. 
2. **Call-by-Need** (Lazy Evaluation): values are not computed until they are actually needed. This permits us to make infinite computations and infinite lists. 
3. **Strong Polymorphic and Static Typing**: every expression has a well-defined type that can be checked at compile time. It also has polymorphic typing, which allows you to write functions that can operate on values of any type as long as they meet certain requirements (type inference ... indeed usually we don´t need to explicitly declare types).


### What is a functional language?

In mathematics, functions do not have side-effects. Haskell is purely funtional, so we will see later how to manage inherently side-effectful computations (e.g. those with I/O).


## Evaluation of functions
 
A function application ready to be performed is called a reducible expression (or **redex**). We basically can have two strategies regarding **evaluations of functions**: 
  
- **call-by-value**: in this strategy, arguments of functions are always evaluated before evaluating the function itself - this corresponds to passing arguments by value.
- **call-by-name**:We start with the redex that is not contained in any other redex. Functions are always applied before their arguments, this corresponds to passing arguments by name.
  
### Haskell is lazy: call-by-need

In **call-by-name**, if the argument is not used, it is never evaluated; if the argument is used several times, it is re-evaluated each time. In Haskell it's used **Call-by-need** which is a *memoized version of call-by-name* where, if the function argument is evaluated, that value is stored for subsequent uses. In a "pure" (effect-free) setting, this produces the same results as call-by-name, and it is usually faster. Call-by-need is very convenient for dealing with **never-ending computations** that provide data

```haskell
makeStream :: [l] -> [l]
makeStream l = l ++ makeStream l

ghci> i = makeStream 1
ghci> take 5 i
[1,1,1,1,1]
```


### Currying 

Currying is an important concept and refers to the fact that functions have only one argument. 

````Haskell
answerToEverything = 42

complexcalc x y z = x * y *  z * answerToEverything

:t complexcalc
complexcalc : : Integer -> Integer -> Integer -> Integer
complexcalc : : Integer-> (Integer -> (Integer -> Integer))
````

The term is a reference to logician Haskell **Curry**. The alternative name Schönfinkelisation has been proposed as a reference to Moses Schönfinkel but didn't catch on.

### Function definition

Functions are declared through a sequence of equations using **pattern matching**. 
Haskell has a powerful mechanism for defining custom data types called "algebraic data types". You should become familiar with how to define and use these types, as well as pattern matching.

````haskell 
first (x,_,_) = x
second (_,x,_) = x
third (_,_,z) = z
first (1,2,3) -> 1
second (1,2,3) -> 2
third (1,2,3) -> 3
````

The `_` means the same thing as it does in list comprehensions. It means that we really don't care what that part is, so we just write a _.

Other useful stuff regarding functions:

- `.` is used for composing functions `(f . g)(x)` is `f(g(x))`
- `$` symbol in Haskell is called the "function application operator". It has a very low precedence, which means that it allows you to avoid using parentheses when applying functions: ``f (g x)`` is like: `f $ g x`. Another way to think about it is that `$` acts as a "parentheses eraser" in function chaining. It is not necessary but makes code concise and readable.

## Data and type

`data` and `type` keywords are both used to define new data structures, but they have different purposes.

- A type is a set of values and it's made using the keyword `data` (and not type lol)
- A type-class is a set of types. 
- A type-class is a way to define operations to other types ... very similar to **interfaces** in for example Java. They are the mechanism provided by Haskell for ad hoc polymorphism.

| Haskell | Java (or similar OOP) |
| :---: | :---: |
| Type Class | Interface |
| Type | Class |
| Value | Object |
| Method | Method |


- `data` is used when you want to define a new type you use `data`. 

```Haskell
data Tree a = Empty | Node a (Tree a) (Tree a)`
```

- `type` is used to define type synonyms, which are alternative names for existing types. For example, you could use `type` to define a synonym for a list of integers:

```Haskell
type IntList = [Int]`
```

- ```newtype``` is 'weird' since we want to make an alias 'basically identical' to another already define ```type``` but I want to say to ghc to consider them two different types.

Recursive Types: 

```haskell
-- Trees
data Tree a = Leaf a | Branch (Tree a) (Tree a)

Branch :: Tree a -> Tree a -> Tree a
aTree = Branch (Leaf 'a') (Branch (Leaf 'b') (Leaf 'c'))

-- Lists are recursive types
data List a = Null | Cons a (List a)
data [a] = [] | a : [a]
```

## Lists

Lists in Haskell are represented by square brackets `[]` and the elements (of the same type) are separated by commas. 

````Haskell
numbers = [1,3,5,7]
numbers !! 2  -> 5 
null numbers -> False --tell us if the list is empty
head numbers -> 1 
tail numbers -> [3,5,7]
init numbers -> [1,3,5]
last numbers -> 7 
drop 2 numbers -> [5,7]
take 2 numbers -> [1,3]
elem 1 [1,2,3] -> True
elem 21 [1,2,3] -> False
````

Example of a list comprehension:

```Haskell
length' xs = sum [1 | _ <- xs]
fi xs = [x | x <- xs, odd x == False]
``` 

## Tuples

`(1,2,3)` in Haskell is a tuple (while `[1,2,3]` is a list). A tuple is a fixed-length, ordered collection of elements. While lists are homogeneous, tuples are heterogeneous.  For example, `(1, "Hello", 3.14)` is a valid tuple in Haskell.

Tuples are useful for when you want to group together a fixed number of elements that may have different types, while lists are useful for when you want to store a sequence of elements that are all of the same type.

scriversi da qualche parte fst and snd stuff 


## Arrays

### Index types

### Array Creation

### Accumulation

### Incremental updates

### An example: Matrix Multiplication


## Let 


````Haskell
let x = 3
y = 12
in x+y -- => 15

--or 
let {x = 3 ; y = 12} in x+y


euler :: Point -> Point -> Float
euler (Point x1 y1) (Point x2 y2) = 
    let dx = x1 - x2 
        dy = y1 - y2 
    in sqrt ( dx*dx + dy*dy )
````

Example with `where`: 

````Haskell
bmi :: Float -> Float -> String 
bmi w h 
    | calc <= 18.5 = "Underweight"
    | calc <= 25.0 ="Normal"
    | calc <= 30.0 = "Overweight"
    | otherwise = "Obese"
    where calc = w/h^2
````

## If 



## Take 

`take` is used to take `n` items from a list: ``take n (x:xs)``. 

If `n` is equal to zero, an empty list is returned. If `n` is greater than the length of the list, the entire list is returned.

## Zip

The `zip` function is a common operation in programming languages that takes two or more lists as input and combines them into a single list of tuples, where each tuple contains corresponding elements from the input lists. 

- Resulting list will have the same length as the shortest input list.
- Especially useful for when you want to combine two lists in a way or traverse two lists simultaneously.

````Haskell
zip [1,2,3,4,5] [5,5,5,5,5]  -- [(1,5),(2,5),(3,5),(4,5),(5,5)]  
zip [1 .. 5] ["one", "two", "three", "four", "five"]  -- [(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
````

Implementation:

````Haskell
zippa :: [a] -> [b] -> [(a,b)]
zippa [] _ = []
zippa _ [] = []
zippa (x:xs) (y:ys) = (x,y) : zippa (xs) (ys)
````

## Equality 


## Show

```Haskell
data Queue a = Queue [a] [a] 

instance (Show a) => Show (Queue a) where 
  show (Queue x y) = show x ++ "|" ++ show y  


data Tree a = Empty | Leaf a | Node (Tree a) (Tree a)

instance Show x => Show (Tree x) where
    show Empty = "()"
    show (Leaf a) = "(" ++ show a ++ ")"
    show (Node a b) = "[" ++ show a ++ show b ++ "]"
```



## Ord



## The Enumeration Class


usually it is not necessary to explicitly define instances of some classes. Haskell can be quite smart and do it automatically, by using deriving. 

````Haskell
data Point = Point Float Float deriving (Show,Eq)
````

Enumeration: 

````Haskell
data RPS = Rock | Paper | Scissors deriving (Show, Eq)

instance Ord RPS where
x <= y | x == y = True
Rock <= Paper = True
Paper <= Scissors = True
Scissors <= Rock = True
_ <= _ = False

````


## Road to Monads

Here is a high-level summary of the steps to reach Monads. Monads are the most powerful of these type classes, and they are used for dealing with side effects like error handling or state management.

- **Foldable**: A type class that enables folding over data structures, such as lists or trees.
- **Functor**: A type class that defines a way to apply a function over a structure, preserving the structure's type.
- **Applicative Functors**: A type class that extends the Functor class to allow for sequential application of functions over multiple structures, with the ability to lift functions of multiple arguments into the context of the structures.
- **Monad**: A type class that extends the Applicative Functor class to enable sequencing of actions or computations, with the ability to chain together actions that may produce values, handle errors, or make decisions based on the results of previous actions.

Actually it's not necessary to implement all these steps to have a Monad.

## Foldable 

Foldable is a class used for folding. The main idea is the same as `foldl` and `foldr` for lists: given a container and a binary operation `f`, we want to apply `f` to all elements in the container.
A minimal implementation of Foldable requires `foldr`.

### Foldr

`foldr` starts from right. 

```Haskell
ghci> :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b 
```

````Haskell 
data Tree a = Empty | Leaf a | Node (Tree a) (Tree a)

tfoldr f z Empty = z
tfoldr f z (Leaf x) = f x z
tfoldr f z (Node l r) = tfoldr f (tfoldr f z r) l

instance Foldable Tree where
foldr = tfoldr

> foldr (+) 0 (Node (Node (Leaf 1) (Leaf 3)) (Leaf 5))
9
````


### Foldl 

The `foldl` function in Haskell is short for "fold left". This means that it starts at the leftmost element of a list and applies a given binary operator to each element and an accumulator value, accumulating the result as it goes.

note: in Racket it is defined with (f x z) !!!!!! 

````Haskell
ghci> :t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

foldl (\acc x -> x + acc) 0 [1,2,3]
````

In ``foldl (+) 0 [1,2,3]`` the steps are:

- Start with an accumulator value of `0`.
- Apply `(+) 0 1`, which gives us a new accumulator value of `1`.
- Apply `(+) 1 2`, which gives us a new accumulator value of `3`.
- Apply `(+) 3 3`, which gives us a final result of `6`.

Example of multiple arguments in the lambda expression of `foldl` :

````haskell
foldl (\acc (x, y) -> x + y + acc) 0 [(1, 2), (3, 4), (5, 6)]
````

Implementation of `elem` with `foldl`: 

````Haskell
isThere y ys = foldl (\acc x -> if x == y then True else acc) False ys
````

`Foldl` can be expressed in term of foldr (id is the identity function):

````Haskell
foldl f a bs = foldr (\b g x -> g (f x b))
````

Actually `foldr` may work on infinite lists, unlike `foldl`: `foldl` starts from left to right but actually it starts to compute the recurrence from the last element (but if it doesn't exists .. that's not possible). 

## Functor 

Functor is the class of all the types that offer a map operation 

Generally it s natural to make every data structure an instance of functor. 

- ```fmap id = id``` (where id is the identity function)
- ```fmap (f.g) = (fmap (f)).(fmap (g))``` (homomorphism)

````Haskell
ftmap :: (a->b) -> (Tree a) -> (Tree b)
ftmap _ Empty = Empty 
ftmap f (Leaf x) = (Leaf (f x))
ftmap f (Node z1 z2) = (Node (ftmap f z1) (ftmap f z2)) 

instance Functor Tree where 
    fmap = ftmap
````


## Applicative Functors 

````Haskell
class (Functor f) => Applicative f where
pure :: a -> f a
(<*>) :: f (a -> b) -> f a -> f b -- <*> means  apply 
````

The `pure` method is a useful helper function for taking an ordinary value or function and putting it into a context.

````Haskell
concat [[1,2],[3],[4,5]] 
[1,2,3,4,5] 

ghci> concatMap (\x -> [x, x+1]) [1,2,3] 
[1,2,2,3,3,4]

ghci> concatMap (++"?") ["a","b","c"]
"a?b?c?"

ghci> concatMap (++"") ["a","b","c"]
"abc"

ghci> concatMap (return "a") ["a","b","c"]
"aaa"


-- with concatMap, we get the standard implementation of <*> (the main op of applicative)

ghci> [(+1),(*2)] <*> [1,2,3]
[2,3,4,2,4,6] 

ghci> z = Node (Leaf (*3)) (Leaf (*2))
ghci> y = Node (Leaf 2) (Leaf 1)
ghci> z <*> y
[[(6)(3)][(4)(2)]]
````

Example with Maybe: 

````Haskell
instance Applicative Maybe where
  pure = Just
  Nothing <*> _ = Nothing
  _ <*> Nothing = Nothing
  Just f <*> Just x = Just (f x)
  ````

````Haskell
instance Applicative Tree where 
    pure x = (Leaf x)
    _ <*> Empty = Empty
    Leaf f1 <*> Leaf x = Leaf (f1 x)
    Node fl fr <*> Node l r = 
        Node (Node (fl <*> l) (fl <*> r))
        (Node (fr <*> l) (fr <*> r))
````

## Monad 

Introduced by Eugenio Moggi in 1991, a monad is a kind of algebraic data
type used to represent computations (instead of data in the domain model) -
we will often call these computations actions . 

### Maybe 

Maybe is used to represent computations that may fail: we either have
data Maybe a = Nothing | Just a

It is adopted in many recent languages, to avoid NULL and limit exceptions
usage: mainly because exceptions are sometimes complex to manage. 


If you are definining Applicative after Functor be consistent!! 


Monad: 

`return = pure `
and then you made pattern matching for each possible combination


```haskell
:t (>>=)
Monad m => m a -> (a -> m b) -> m b 
```

The implementation with monad permits me to perform 
specific operations with `==>` and with "`do` notation"

Note that `do` is a "syntax sugar"


The "do notation" in Haskell is considered a syntax sugar because it provides a more readable and convenient way of writing Monadic code. "Do notation" takes the form of a series of statements separated by "bind" operations represented by the `<-` symbol. Behind the scenes, the "do notation" is translated into chains of bind operations (also known as "flatMap" or "bind" in other functional programming languages) which have a more complex syntax and can be harder to read. The use of the "do notation" makes it easier to write code that is easier to read, understand, and maintain, while still having the same underlying behavior as the equivalent code written using only bind operations.



Additionally, using "if" statements in functional programming is generally discouraged, as functions should avoid side effects and return values based on their inputs, not on conditions.

monads allow the programmer to chain actions together to build an ordered
sequence, in which each action is decorated with additional processing
rules provided by the monad and performed automatically 

monads are flexible and abstract. This makes some of their applications a
bit hard to understand.

monads can also be used to make imperative programming easier in a pure
functional language 

Monad is a subclass of Applicative . 

The monad is just a way to composing your actions and computations. 


-- Sequentially compose two actions, passing any value produced
-- by the first as an argument to the second.
(>>=)
:: m a -> (a -> m b) -> m b

-- Sequentially compose two actions, discarding any value produced
-- by the first, like sequencing operators (such as the semicolon)
-- in imperative languages.
(>>)

bind is a way to compose computations making a sequence of actions. 

1) return is the identity element:
(return x) >>= f <=> f x
m >>= return <=> m
2) associativity for binds:
(m >>= f) >>= g <=> m >>= (\x -> (f x >>= g))



We couldn't have achieved this by just using Maybe as an applicative. If you try it, you'll get stuck, because applicative functors don't allow for the applicative values to interact with each other very much. They can, at best, be used as parameters to a function by using the applicative style. The applicative operators will fetch their results and feed them to the function in a manner appropriate for each applicative and then put the final applicative value together, but there isn't that much interaction going on between them. Here, however, each step relies on the previous one's result. On every landing, the possible result from the previous one is examined and the pole is checked for balance. This determines whether the landing will succeed or fail.


A value of type Maybe a represents a value of type a with the context of possible failure attached. A value of Just "dharma" means that the string "dharma" is there whereas a value of Nothing represents its absence, or if you look at the string as the result of a computation, it means that the computation has failed.

allows us to feed a monadic value to a function that takes a normal one.

Converting this monstrosity into a neat chain of monadic applications with >>= is a classic example of how the Maybe monad saves us a lot of time when we have to successively do computations that are based on computations that might have failed.


Monads in Haskell are so useful that they got their own special syntax called do notation. We've already encountered do notation when we were doing I/O and there we said that it was for gluing together several I/O actions into one. Well, as it turns out, do notation isn't just for IO, but can be used for any monad. Its principle is still the same: gluing together monadic values in sequence. We're going to take a look at how do notation works and why it's useful.

````Haskell
ghci> show [1,13..100] 
[1,13,25,37,49,61,73,85,97]
-- [x,k..u] is a a list with upper bound "u" and a step of "x-k"  
````


Monads are a way of structuring computations, and provide a way to wrap values with additional context. They are used to provide a way to sequence computations and manage side effects, such as input/output or error handling.


```(>>=)```  sequentially compose two actions, discarding any value produced by the first, like sequencing operators in imperative languages. 

The do syntax is used to avoid the explicit use of ```(>>=)```  , this is like the begin structure in [Scheme](00.Scheme.md) . 

SBAGLIATO ... DA CORREGGERE 

````Haskell
instance Monad  Maybe where: 
(Just x) >>= k            -- k x  
Nothing  >>= _           --Nothing 
fail _                 --Nothing   
````


The list Monad is the foundation of list comprehension. 
A monad is just an operation which gives the possibility of compose monadic actions one after the other. What is a monadic action? That actually depends on how you define your monad. 


In Haskell, a monad is a way to structure computations. It is a way to define a sequence of steps that can be combined and reused. Monads are used to abstract away common patterns in code, making it easier to write and understand complex programs. A monad is a type of abstract data type that has a specific set of operations defined for it, such as bind and return. These operations allow you to combine monads and create new ones, making it easier to write programs in a functional style.



```haskell
-- Define a Monad instance for Tree.
instance Monad Tree where
  -- Define 'return' (also known as 'pure') to create a new leaf node with the given value.
  return = Leaf
  -- For an empty tree, simply return another empty tree.
  Empty >>= f = Empty
  -- For a leaf node containing value x, apply function f to x and return the result.
  Leaf x >>= f = f x
  -- For a non-leaf node with left subtree l and right subtree r,
  -- recursively apply function f to both subtrees and combine them into one larger tree using Node constructor.
  Node l r >>= f = Node (l >>= f) (r >>= f)
```

This implementation allows us to use standard monadic operations like bind (`>>=`) on trees constructed using our custom datatype. Specifically:

- We can use `return` or `pure` to create new trees containing single values wrapped in our monadic context (i.e., inside our custom datatype).
- We can use bind (`>>=`) operator on any existing tree constructed from our datatype by applying some function that takes its input wrapped in our monadic context and returns another element also wrapped in same context.

With these definitions in place, we can now work with trees just like any other monad!

---


Instead of doing the `>==` concatenation .. just do "do" thing. 



### The State Monad


We can do IO with it. We now define a general monad to do it: btw it is already available in the libraries ```Control.Monad.State```. 
First of all, we define a type to represent our state:
The idea is having a type that represent a computation with a state.  

(1) The same approach can be used for the monad definition: instance Monad (State state) where


(1) An important aspect of this monad is that monadic code does not get evaluated to data, but to a function! (Note that State is a function and bind is function composition)

  

(2) In particular, we obtain a function of the initial state

  

(3) To get a value out of it, we need to call it:


```Haskell
type Log = [String] --remember that is just an alias
data Logger a = Logger a Log

instance (Eq a) => Eq (Logger a) where
    (Logger x _) == (Logger y _) = x == y

instance (Show a) => Show (Logger a) where
   show (Logger x s) = show x ++ "{" ++ show s ++ "}"

instance Functor Logger where 
    fmap f (Logger x s) = Logger (f x) s 

instance Applicative Logger where
    pure x = Logger x ["Init"]
    Logger f f_name <*> (Logger x log) =  (Logger (f x) (log ++ f_name))

instance Monad Logger where 
    return = pure 
    (Logger x l) >>= f = 
        let Logger x' l' = f x
        in Logger x' (l ++ l') 
```


```Haskell
data CashReg a = CashReg { getReceipt :: (a,Float) } deriving (Show, Eq)

getCurrentItem = fst . getReceipt 
getPrice = snd . getReceipt

instance Functor CashReg where 
    fmap f cr = CashReg (f $ getCurrentItem cr, getPrice cr)

instance Applicative CashReg where 
    pure a = CashReg (a,0.0)
    fcr <*> cr = CashReg (getCurrentItem fcr $ getCurrentItem cr, getPrice fcr + getPrice cr) 

instance Monad CashReg where 
    return = pure 
    cr >>= f = 
        let newCr = f $ getCurrentItem cr 
        in CashReg (getCurrentItem newCr, getPrice cr + getPrice newCr)
```



## Misc

### Modules

Haskell has a simple module system, with import, export and namespaces. 
Modules provide the only way to build abstract data types (ADT)

### IO

IO is not 'compatible' with the functional philosophy. In general, IO computation is based on state change (e.g. of a file), hence if
we perform a sequence of operations, they must be performed in order
(and this is not easy with call-by-need).
```IO``` is an instance of the monad class.
Main is the default entry point of the program:

````Haskell
main = do { --sequence of IO actions
putStr "Please, tell me something>";
thing <- getLine; --a way to get the input
putStrLn $ "You told me \"" ++ thing ++ "\".";
}
````
 
```Haskell
import System.IO
import System.Environment

readfile = do {
    args <- getArgs; -- command line arguments
    handle <- openFile (head args) ReadMode;
    contents <- hGetContents handle; 
    putStr contents;
    hClose handle;
}

main = readfile
```
