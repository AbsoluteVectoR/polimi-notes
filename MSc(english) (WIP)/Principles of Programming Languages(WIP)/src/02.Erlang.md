
# Erlang

Initially developed for telecommunication applications such as switches, Erlang is a concurrent-oriented functional language that has almost transparent distribution. 
Erlang runs on an ad hoc **VM** called **BEAM**. BEAM offers many features for parallel and distributed systems, including slow performance degradation and fault-tolerance, making it very robust. Erlang has been used in several relevant industrial applications such as WhatsApp, Amazon's SimpleDB, and Facebook's chat function.
One of Erlang's core principles is the "**let it crash**" principle. This principle involves designing the application with a supervision structure in place to handle errors and crashes. When an error occurs, the process responsible for the error is terminated, and supervision processes restart it and other necessary processes.
Erlang also supports **hot-swapping** of code, allowing for updating application code at runtime. Processes running the previous version of the code continue to execute, while new invocations run the updated code. Erlang syntax is heavily influenced by Prolog. 

## Integers 

Integers in Erlang are used to denote whole numbers (positive or negative). In Erlang there is no maximum size for integers and arbitrarily large whole numbers can be used. 
It's also easy to express integers in different bases other than 10 usng the `Base#Value` notation. If omitted, base 10 is assumed. 
Operations on integers are standard except that the `/` operator is used only for floating point division while the `div` operator is used for integer division. 

### Equality

In Erlang, expressions can be compared using the following operators:

```erlang
== Equal to
/= Not equal to
=:= Exactly equal to
=/= Exactly not equal to
=< Less than or equal to
< Less than
<= Less than or equal to
```


## Atoms

Atoms are like symbols in Scheme: constant literals that stands for themselves. They are similar to enumeration types in other programming languages.
If the atom is not enclosed in quotes, valid characters are letters, digits, the AT symbol (`@`) and the underscore (`_`). If the atom is enclosed in single quotes, any character is allowed.

### Booleans

The atoms `true` and `false` are just atoms already defined. The following Boolean operators are available:

- `and`
- `andalso`
- `or`
- `orelse`
- `xor`
- `not`

## Variables

Variables in Erlang have some rules like:

- There is the "Single Assignment": once you've bound a variable, you cannot change its value ... so yeah .. it's  not a variable. 
- They start with an **uppercase letter**, followed by uppercase and lowercase letters, integers and underscores.

## Tuples

Tuples are used to store a fixed number of items. They can contain any type of data and they are delimited by `{ }` :

```erlang 
> element(1, {martino,piaggi}). 
martino
> element(2, {martino,piaggi}). 
piaggi
```

### Records 

In Erlang, records are just a special syntax for tuples. They are used to create structures with named fields. For example, a record for a person could be created with `#person{name='Jim', nationality='Austrian'}`. This is equivalent to the tuple `{person, 'Jim', 'Austrian'}`. 

## Lists

Erlang offers also **lists**, which are delimited by square brackets (like in Haskell) and their elements are comma-separated. 

### List comprehensions 


## Pattern Matching

Pattern matching is more expressive than Haskell. `Pattern = Expression` can be used to:

- Assign values to variables, for example: `{a, b, C} = {a, b, foo}.` is a way to bound `C` variable to atom `foo`. 
- Control the execution flow of programs
- Extract values from compound data types

## Functions 

Erlang function definitions can't be typed directly in the Erlang shell but they are grouped together in **modules**. Examples of built-in functions are:

```
date ()
time ()
size ( {a, b, c})
atom_to_list (an_atom)
integer_to_list (2234)
tuple_to_list ({Y})
```


### Function Syntax & Evaluation

- The arrow `->` separates the head of the function from its body. 
- The function can consists of one or more clauses, separated by semicolons `;` except for the last one which is terminated by a dot `.`
- Each clause defines the action of the function on data which matches the pattern in the head of the clause.
- Clauses are scanned in order until a match is found.
- When a match is found, variables in the head of the clause are bound.
- Variables in each clause are local and are allocated and deallocated automatically.
- The body of the clause is evaluated sequentially using commas to separate expressions.


### Guarded Function Clauses

```erlang
factorial (0) -> 1;
factorial (N) when N > 0 ->
N * factorial (N - 1) .
```

Erlang uses guarded function clauses to define functions. A guard is introduced using the keyword `when`. It is similar to Haskell.
The guard sub-language is restricted because it must be evaluated in constant time. This means users cannot use their own predicates while using guards.

#### Examples of Guards

## Apply


## Maps

Erlang has maps which are similar to hash tables.


## Concurrent Programming: the Actor Model

Concurrent part is the most important part of the language.  Erlang is nice to write concurrent programs but still it's not a silver bullet. It will be particularly bad at things like image and signal processing and will shine at things like large software for server. 

Erlang relies on the "Actor Model", in which actors (independent unit of computation) can only communicate through messages. 
Processes are represented using different actors communicating only through messages. Each actor is a lightweight process, handled by the VM: it is not mapped directly to a thread or a system process, and the VM schedules its execution.

### Simple Message Passing

The syntax `!` is used to send anything to any other actor/process:

````erlang

B ! {self(),{mymessage,[1,2,3,42]}}

Then in b: 

receive
	{A,{mymessage,D}} -> work_on_data(D);
end
````

With Erlang library you can make very easily and quickly a client-server system. 
There is construct to make:

````erlang
sleep (T) ->   
	receive   
		foo -> Actions1 
	after   
	... Time -> Actions2
	end.
````

In this way we can build **sleep** function: 

````erlang
sleep (T) ->   
	receive   
	after   
		T -> true   
	end.
````

When creating a new process in Erlang, it is assigned a process identifier (Pid), which is known only to the parent process. A process can send a message to another process using its identifier. 

- ```register(Alias,Pid)``` is a way to make an alias in complex applications. 
- There is also ```Flush()``` to clear message queue. 

Messages can carry data and provided that the data is applicable, variables can become bound when receiving the message. 

## Shell commands 

Please note that in Erlang shell every instruction must be terminated by a dot `.` .

`f()` is used to "forget" all possible value bounds to the assignments. `f(Variable)` if you want to unbound a specific variable. 


## Links and resources

-   Erlang
	- https://www.tryerlang.org/ 
    -   [Learn you some Erlang](http://learnyousomeerlang.com/content)
    -   [Main Erlang site, with the standard implementation and documentation](http://www.erlang.org/)
    -   [Elixir, an Erlang VM-based language](http://elixir-lang.org/)



## Exe

https://replit.com/@MartinoPiaggi/Erlang#main.erl 

Funs are used to define anonymous functions like `lambda` in Scheme. 

```erlang
F = fun (Arg1, Arg2, ... ArgN) -> ... End
```

```erlang
4> lists:foldl (fun (X,Y) -> X+Y end, 0, [1,2,3]).
6
```

