-   Erlang
    
    -   [Learn you some Erlang](http://learnyousomeerlang.com/content)
    -   [Main Erlang site, with the standard implementation and documentation](http://www.erlang.org/)
    -   [Elixir, an Erlang VM-based language](http://elixir-lang.org/)



Concurrent part is the most important part of the language. 
Erlang is nice to write concurrent programs.
Actor Model. Actor=independent unit of computation. Actors can only communicate through messages. 
Processes are represented using different actors communicating only through messages. Each actor is a lightweight process, handled by the VM: it is not mapped directly to a thread or a system process, and the VM schedules its execution The VM handles multiple cores and the distribution of actors in a network Creating a process is fast, and highly concurrent applications can be faster than the equivalent in other programming languages

```!``` to send anything to any process. Then ```receive``` and ```extract``` operation. 

````erlang

B ! {self(),{mymessage,[1,2,3,42]}}

Then in b: 

receive
	{A,{mymessage,D}} -> work_on_data(D);
end
````

With Erlang library you can make very easily and quickly a client-server system. 

There is construct to make  
````erlang
sleep (T) ->   
	receive   
		foo -> Actions1 //if foo it's not present, this construct waits Time and then makes actions2
	after   
	... Time -> Actions2
	end.
````
In this way we can build sleep function: 
````erlang
sleep (T) ->   
	receive   
	after   
		T -> true   
	end.
````

```register(Alias,Pid)``` is a way to make an alias in complex applications. 
There is also ```Flush()``` to clear message queue. 

Applications structure is based on the concept of supervision: "let it crash" principle for any process. Support to code hot-swap: application code can be loaded at runtime, and code can be upgraded: the processes running the previous version continue to execute, while any new invocation will execute the new code. 


## Introduction

In 1986, Erlang was introduced by Joe Armstrong, Robert Virding, and Mike Williams while working at Ericsson. It was initially developed for telecommunication applications such as switches. Erlang is a concurrent-oriented programming language that has almost transparent distribution. Its core is functional, and its syntax is heavily influenced by Prolog. The language is dynamically-typed like Scheme.

Erlang's standard library for distributed fault-tolerant applications is called OTP (Open Telecom Platform). OTP supports continuously running applications and updates with code swap. The core of the language is functional, but not pure like Haskell, which suits its industrial setting.

## The Erlang VM (BEAM)

Erlang runs on an ad hoc VM called BEAM. BEAM offers many features for parallel and distributed systems, including slow performance degradation and fault-tolerance, making it very robust. Erlang has been used in several relevant industrial applications such as WhatsApp, Amazon's SimpleDB, and Facebook's chat function.



# Syntax: Variables

Variables in Erlang have some rules like:

- They start with an uppercase letter
- They use CamelCase
- A variable can only be set once, and its value cannot be changed


## 7. Atoms

(1) Atoms are like symbols in Scheme.

(2) Any character code is allowed within an atom, singly quoted sequences of characters are atoms (not strings).

(3) unquoted must be lowercase, to avoid clashes with variables

Atoms in Erlang are similar to symbols in Scheme. These values can consist of any character code and can also be represented by singly quoted sequences of characters. 

## 8. Tuples

Tuples are used to store a fixed number of items. They can contain any type of data and are enclosed in curly braces. For example, {123, def, abc} is a tuple containing an integer, an atom, and a string.

In Erlang, records are a special syntax for tuples. They are used to create structures with named fields. For example, a record for a person could be created with the syntax: 

`#person{name='Jim', nationality='Austrian'} `

This is equivalent to the tuple `{person, 'Jim', 'Austrian'}`. 

It is worth noting that records are not a separate data type in Erlang and are simply a way of organizing data within tuples.


## 9. Lists


- Erlang has similarities with Haskell in terms of using [ ] to denote lists and ++ operator for concatenation.
- The main difference is the use of cons, denoted by |, similar to LISP's cons function.
- Strings are also represented as lists in Erlang, but there is a growing trend to use bitstrings and UTF format.
- Comprehensions in Erlang have similarities with Haskell, denoted by [ ], allowing for compact expressions and list generators.
- Erlang also has special syntax and features for working with bit sequences, as well as support for comprehensions.

## Pattern Matching

Pattern matching is more expressive than Haskell. 


## Functions


Function and module names must be atoms, and functions are defined within modules.

Functions must be exported before they can be called from outside the module where they are defined. It is discouraged to use-import to avoid qualified names. 

Functions are defined with arguments (Arg1, Arg2, ... Argn), and they can be called within Modules.

### Built In Functions (BIFs in Erlang jargon)

(1) BIFs are in the erlang module

(2) They do what you cannot do (or is difficult to do, or too slow) in Erlang, and are usually implemented in

.


```
`date ( )
time ( )
size ( {a, b, c})
atom_to_list (an_atom)
integer_to_list (2234)
tuple_to_list ( {Y)
"an _ atom"
2234"`
```




## Maps

Erlang has maps which are similar to hash tables.


## Module System


### Function Syntax & Evaluation

(1) A function is defined as a sequence of clauses.

func(Pattern1, Pattern2, ...)

... .

(2) Clauses are scanned sequentially until a match is found.

(3) When a match is found all variables occurring in the head become bound.

(a) Variables are local to each clause, and are allocated and deallocated automatically.

(5 The body is evaluated sequentially (use "," as separator).


## Guarded Function Clauses

```erlang
factorial (0) -> 1;
factorial (N) when N > 0 ->
N * factorial (N - 1) .
```


Erlang uses guarded function clauses to define functions. A guard is introduced using the keyword "when". It is similar to Haskell.
The guard sub-language is restricted because it must be evaluated in constant time. This means users cannot use their own predicates while using guards.

## Examples of Guards


## 20. Apply



## Concurrent Programming: the Actor Model

## Concurrency oriented programming language

## Concurrent programming

## Creating a New Process

## Simple Message Passing


Erlang is a concurrency-oriented programming language that follows the Actor Model, which was introduced by Carl Hewitt, Peter Bishop, and Richard Steiger in 1973. According to this model, everything is an actor, which is an individual unit of computation that can only communicate with other actors through messages, and is inherently concurrent. Actors can be created dynamically, and there are no restrictions concerning the order of received messages.

In Erlang, processes are represented using different actors that communicate only through messages. Each actor is a lightweight process managed by the virtual machine (VM), and the VM schedules its execution. Thus, it is not mapped directly into a thread or a system process. Creating a process is fast and efficient, and highly concurrent applications can be faster than the equivalent in other programming languages. The VM handles multiple cores and the distribution of actors in a network.

To create a new process in Erlang, we can use the spawn primitive. It creates a new process executing the specified function and returns an identifier. We can then use the send primitive, which sends a message to a process through its identifier. The content of the message can be any variable. The operation is asynchronous. Finally, receive extracts, blocking if necessary, the first message from a process's mailbox queue that matches the provided set of patterns.

When creating a new process in Erlang, it is assigned a process identifier (Pid), which is known only to the parent process. A process can send a message to another process using its identifier. Messages can carry data and provided that the data is applicable, variables can become bound when receiving the message. If the receiver's identity is known beforehand, only data sent from that process is accepted.




## An Echo process


## Selective Message Reception

## Selection of any message


## Registered Processes


## Client Server Model


## Timeouts


### Uses of Timeouts (1)

flush () - flushes the message buffer


## Let it crashes

Erlang is an excellent option for building reliable and scalable applications, thanks to its OTP (Open Telecom Platform) libraries and design principles. These principles include the use of ready-to-use design patterns called "behaviours." These behaviours, such as servers and supervisors, only require implementation of the functional part through callback functions.

One of Erlang's core principles is the "let it crash" principle. This principle involves designing the application with a supervision structure in place to handle errors and crashes. When an error occurs, the process responsible for the error is terminated, and supervision processes restart it and other necessary processes.

Erlang also supports hot-swapping of code, allowing for updating application code at runtime. Processes running the previous version of the code continue to execute, while new invocations run the updated code.

An example of the "let it crash" principle in action involves a supervisor linked to several workers tasked with adding numbers to their local state. Once a worker's state reaches 30, it ends its activity. The supervisor sends "add" messages to the workers and tracks how many are still active. If a worker encounters an error, the supervisor restarts it to ensure the application runs smoothly.



