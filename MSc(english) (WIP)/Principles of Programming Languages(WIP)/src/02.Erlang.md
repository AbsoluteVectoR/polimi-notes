
# Erlang

Initially developed for telecommunication applications such as switches, Erlang is a concurrent-oriented functional language that has almost transparent distribution. 
Erlang runs on an ad hoc **VM** called **BEAM**. BEAM offers many features for parallel and distributed systems, including slow performance degradation and fault-tolerance, making it very robust. Erlang has been used in several relevant industrial applications such as WhatsApp, Amazon's SimpleDB, and Facebook's chat function.
One of Erlang's core principles is the "**let it crash**" principle. This principle involves designing the application with a supervision structure in place to handle errors and crashes. When an error occurs, the process responsible for the error is terminated, and supervision processes restart it and other necessary processes.
Erlang also supports **hot-swapping** of code, allowing for updating application code at runtime. Processes running the previous version of the code continue to execute, while new invocations run the updated code. Erlang syntax is heavily influenced by Prolog. 

## Integers 

Integers in Erlang are used to denote whole numbers (positive or negative). In Erlang there is no maximum size for integers and arbitrarily large whole numbers can be used. 
It's also easy to express integers in different bases other than 10 usng the `Base#Value` notation. If omitted, base 10 is assumed. 
Operations on integers are standard except that the `/` operator is used only for floating point division while the `div` operator is used for integer division. 

### Equality

In Erlang, expressions can be compared using the following operators:

```erlang
== Equal to
/= Not equal to
=:= Exactly equal to
=/= Exactly not equal to
=< Less than or equal to
< Less than
<= Less than or equal to
```


## Atoms

Atoms are like symbols in Scheme: constant literals that stands for themselves. They are similar to enumeration types in other programming languages.
If the atom is not enclosed in quotes, valid characters are letters, digits, the AT symbol (`@`) and the underscore (`_`). If the atom is enclosed in single quotes, any character is allowed.

### Booleans

The atoms `true` and `false` are just atoms already defined. The following Boolean operators are available:

- `and`
- `andalso`
- `or`
- `orelse`
- `xor`
- `not`

## Variables

Variables in Erlang have some rules like:

- There is the "Single Assignment": once you've bound a variable, you cannot change its value ... so yeah .. it's  not a variable. 
- They start with an **uppercase letter**, followed by uppercase and lowercase letters, integers and underscores.

## Tuples

Tuples are used to store a fixed number of items. They can contain any type of data and they are delimited by `{ }` :

```erlang 
> element(1, {martino,piaggi}). 
martino
> element(2, {martino,piaggi}). 
piaggi
```

### Records 

In Erlang, records are just a special syntax for tuples. They are used to create structures with named fields. For example, a record for a person could be created with `#person{name='Jim', nationality='Austrian'}`. This is equivalent to the tuple `{person, 'Jim', 'Austrian'}`. 

## Lists

Erlang offers also **lists**, which are delimited by square brackets (like in Haskell) and their elements are comma-separated. 

### List comprehensions 


## Pattern Matching

Pattern matching is more expressive than Haskell. `Pattern = Expression` can be used to:

- Assign values to variables, for example: `{a, b, C} = {a, b, foo}.` is a way to bound `C` variable to atom `foo`. 
- Control the execution flow of programs
- Extract values from compound data types

## Functions 

Erlang function definitions can't be typed directly in the Erlang shell but they are grouped together in **modules**. Examples of built-in functions are:

```
date ()
time ()
size ( {a, b, c})
atom_to_list (an_atom)
integer_to_list (2234)
tuple_to_list ({Y})
```


### Function Syntax & Evaluation

- The arrow `->` separates the head of the function from its body. 
- The function can consists of one or more clauses, separated by semicolons `;` except for the last one which is terminated by a dot `.`
- Each clause defines the action of the function on data which matches the pattern in the head of the clause.
- Clauses are scanned in order until a match is found.
- When a match is found, variables in the head of the clause are bound.
- Variables in each clause are local and are allocated and deallocated automatically.
- The body of the clause is evaluated sequentially using commas to separate expressions.


### Guarded Function Clauses

```erlang
factorial (0) -> 1;
factorial (N) when N > 0 ->
N * factorial (N - 1) .
```

Erlang uses guarded function clauses to define functions. A guard is introduced using the keyword `when`. It is similar to Haskell.
The guard sub-language is restricted because it must be evaluated in constant time. This means users cannot use their own predicates while using guards.

#### Examples of Guards

## Apply


## Maps

Erlang has maps which are similar to hash tables.


In Erlang, maps are a data structure that allows you to store key-value pairs. They were introduced in Erlang/OTP 17 and provide an efficient way to work with structured data.

Maps can be created using the `#{}` syntax, where keys and values are separated by a colon (`:`) and each pair is separated by a comma (`,`). For example:

```
Map = #{name => "John", age => 30}.
```

This creates a map with two key-value pairs: `"name"` maps to `"John"`, and `"age"` maps to `30`.

You can access values in a map using the `.` operator followed by the key name. For example:

```
Name = Map.name.
Age = Map.age.
```

This sets `Name` to `"John"` and `Age` to `30`.

Maps also support pattern matching, which makes it easy to extract specific values from them. For example:

```
#{name := Name} = Map.
```

This sets `Name` to `"John"`. The double colon (`:=`) is used for pattern matching instead of the single colon (`:`) used when creating maps.

Maps can be updated using the same syntax as when creating them. For example:

```
NewMap = Map#{age => 31}.
```

This creates a new map that is identical to the original except that the value associated with `"age"` has been changed from `30` to `31`.

Overall, maps provide an efficient way of working with structured data in Erlang.

<hr class="__chatgpt_plugin">

role::user

how to access only a field?

<hr class="__chatgpt_plugin">

role::assistant

To access only a specific field in an Erlang map, you can use the dot notation followed by the name of the field. For example, if you have a map with fields `name`, `age`, and `address`, and you want to access only the value of the `age` field, you can do it like this:

```
Map = #{name => "John", age => 30, address => "123 Main St"}.
Age = Map.age.
```

In this example, we create a map with three fields using the syntax `#{}`. Then we access only the value of the `age` field by using dot notation (`Map.age`) and assign it to a variable called `Age`.

The result will be that `Age` is assigned to 30 because that's what was stored in the original map for that particular key.

Note that if you try to access a non-existent key in a map using dot notation, Erlang will raise an error. So make sure that your maps always contain all necessary keys before trying to access them.

<hr class="__chatgpt_plugin">

role::user

it's not working


<hr class="__chatgpt_plugin">

role::assistant

I apologize for the confusion. It seems that my previous response was incorrect.

In Erlang, you can access a specific field in a map using pattern matching. Here's an example:

```
Map = #{name => "John", age => 30, address => "123 Main St"}.
#{age := Age} = Map,
```

In this example, we create a map with three fields using the syntax `#{}`. Then we use pattern matching to extract only the value of the `age` field and assign it to a variable called `Age`.

The result will be that `Age` is assigned to 30 because that's what was stored in the original map for that particular key.

Note that if you try to access a non-existent key in a map using pattern matching, Erlang will raise an error. So make sure that your maps always contain all necessary keys before trying to access them.


## Concurrent Programming: the Actor Model

Concurrent part is the most important part of the language.  Erlang is nice to write concurrent programs but still it's not a silver bullet. It will be particularly bad at things like image and signal processing and will shine at things like large software for server. 

Erlang relies on the "Actor Model", in which actors (independent unit of computation) can only communicate through messages. 
Processes are represented using different actors communicating only through messages. Each actor is a lightweight process, handled by the VM: it is not mapped directly to a thread or a system process, and the VM schedules its execution.

### Simple Message Passing

The syntax `!` is used to send anything to any other actor/process:

````erlang

B ! {self(),{mymessage,[1,2,3,42]}}

Then in b: 

receive
	{A,{mymessage,D}} -> work_on_data(D);
end
````

With Erlang library you can make very easily and quickly a client-server system. 
There is construct to make:

````erlang
sleep (T) ->   
	receive   
		foo -> Actions1 
	after   
	... Time -> Actions2
	end.
````

In this way we can build **sleep** function: 

````erlang
sleep (T) ->   
	receive   
	after   
		T -> true   
	end.
````

When creating a new process in Erlang, it is assigned a process identifier (Pid), which is known only to the parent process. A process can send a message to another process using its identifier. 

- ```register(Alias,Pid)``` is a way to make an alias in complex applications. 
- There is also ```Flush()``` to clear message queue. 

Messages can carry data and provided that the data is applicable, variables can become bound when receiving the message. 

## Shell commands 

Please note that in Erlang shell every instruction must be terminated by a dot `.` .

`f()` is used to "forget" all possible value bounds to the assignments. `f(Variable)` if you want to unbound a specific variable. 


## Links and resources

-   Erlang
	- https://www.tryerlang.org/ 
    -   [Learn you some Erlang](http://learnyousomeerlang.com/content)
    -   [Main Erlang site, with the standard implementation and documentation](http://www.erlang.org/)
    -   [Elixir, an Erlang VM-based language](http://elixir-lang.org/)



## Exe

https://replit.com/@MartinoPiaggi/Erlang#main.erl 

Funs are used to define anonymous functions like `lambda` in Scheme. 

```erlang
F = fun (Arg1, Arg2, ... ArgN) -> ... End
```

```erlang
4> lists:foldl (fun (X,Y) -> X+Y end, 0, [1,2,3]).
6
```

### lambdas 

Lambdas can be passed as usual to higher order functions: `lists:map(Square, [1,2,3] ).` returns `[1,4,9]`. 

To pass standard (i.e. "non-lambda") functions, we need to prefix their name with fun and state their arity: `lists:foldr(fun my_function/2, 0, [1,2,3]).` 

```
setAlarm(T,What)->
    spawn(?MODULE,set,[self(),T,What]),
    receive
        {Alarm} -> io:format("~p~n", [Alarm])
    end.
```

This will print out the contents of `Alarm` using Erlang's format string syntax (`~p`) and then add a newline character (`~n`). This way, when you call `setAlarm(100,ciao).`, it will print out "ciao" instead of "ok".

https://www.erlang.org/doc/reference_manual/expressions.html