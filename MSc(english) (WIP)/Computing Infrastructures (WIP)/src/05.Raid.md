
# Raid prologue

RAID increases performance, size, and reliability of storage systems by utilizing several independent disks as a single, large, high-performance logical disk. 
Data is striped across multiple disks, allowing for high data transfer rates as well as load balancing across the disks. 

Two orthogonal techniques: 

- data striping: to improve performance 
- redundancy: to improve reliability

## Data striping 

![](images/705b72e91c81cce2263b722da1922693.png)

Data is written on multiple disks according to a **cyclic algorithm** (round robin). 

# RAID 

Redundancy is used to tolerate disk failures with **error correcting codes**. The codes are calculated and stored separately from the data and this permits the **magic** of RAID 3, 4,5,6 etc. Write operations also update the redundant information, so **performance is worst** than traditional writes.

Super simple example of the idea that is the foundation of RAID:

![](images/7a859bae7ff2baa5ba737cc65ce92230.png)



## RAID levels 

RAID types:

- RAID 0: Striping only
- RAID 1: Mirroring only
  - RAID 0+1
  - RAID 1+0
- RAID 2: Bit interleaving (not used)
- RAID 3: Byte interleaving with redundancy (parity disk)
- RAID 4: Block interleaving with redundancy (parity disk)
- RAID 5: Block interleaving with redundancy (distributed parity block)
- RAID 6: Greater redundancy with tolerance for 2 failed disks.


### RAID 0 

Faster than using a single disk, but reliability is reduced because two disks are more likely to fail than one. Best write performance config since there is no need to update redundant data but still it's a parallelized approach.

![](images/57ed4bd88b4eb57565f9dad1f6d5f091.png)

Formulas: 

$$Disk = logical_{block \_ number} \space \space mod \space \space (number_{disks})$$
$$Offset = \frac{logical_{block \_ number}}{(number_{disks})}$$
Capacity: 

- All space on drives can be filled with data 

Reliability: 

- If a drive fails, data is permanently lost 
- $MTTDL = MTTF$ 

Sequential read and write (where $S$ is sequential transfer rate):

- Full parallelization across drives $N * S $

Random read and write (where $R$ is sequential transfer rate):

- Full parallelization across all drives $N * R$


![](images/bae4e9ce15d2efda68f53cfefac07d51.png){width=50%}

### RAID 1


![](images/eeb33ed49b7d79b9efd91106994d9be4.png){width=50%}


### RAID x + y

We can use the notation RAID $x+y$ to say:

- $n*m$ is the total number of disks
- $m$ groups of $n$ disks and applying RAID $x$ to each group before applying RAID $y$ to treat the $m$ groups as single disks.

Basically the number $y$ in the notation RAID $x+y$ indicates the **upper** organization. 

Example of RAID 0 (striped disks) + RAID 1 (mirrored) : 

![](images/d7fd67bac0936f270e368e06130eee9a.png){width=50%}

Example of RAID $1$ (mirrored disks) + RAID $0$ (striped) : 

![](images/d9c2e2c2d46fb8092cbe3ace1fa8bd46.png){width=50%}


![](images/6d8a6b1645d7f6415e4e9955f5be98ad.png){width=50%}

RAID $1+0$ and RAID $0+1$ have the same blocks but allocated differently. The result is that both have the same performance and storage but **RAID $1+0$ has a higher fault tolerance compared to RAID $0+1$ on most RAID controllers**.

> "The problem is that in RAID $0$ if one disk fails the overall RAID $0$ system fails. So in case of the two different configurations, the one with less disks in RAID 0 has an higher reliability."

For this motivation RAID $0+1$ is never used. 

Formulas: 

- Capacity is $\frac{N}{2}$ 
- If you are lucky,  $\frac{N}{2}$  drives can fail without data loss
- the sequential write is $(\frac{N}{2})*S$
- the random **reading** doesn't suffer of block skipping so $N*R$ 
- since we have to copy two time the same information we have that the random **writing** is $(\frac{N}{2})*R$

#### The problem with RAID x+y 

The issue with these systems is that information have to be or committed or not committed at all. **Partially commited** data is very dangerous since it gives inconsistencies to the system. This is a problem when there are power failures.


### RAID 4 