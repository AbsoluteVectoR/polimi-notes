

TOMASULO

  

  

The goal of this algorithm is the same of scoreboard:

high performance without compiler intervention.

  

  

Scoreboard is centralized, while in Tomasulo approach are distributed

and nearer to the functional units. Operand buffers are called

reservation station. Tomasulo's architectures resolves WAW and WAR

hazards efficiently by exploiting register renaming.

  

  

ISSUE: Get the instruction from the queue and if a RS is ready, set the right values of it. If there's

no station available, the operation is stalled: we're in presence of a

structural hazards. n this step registers are renamed, avoiding WAR and WAW hazards.

  


TOMASULO LOAD/STORE EXCEPTION:


Loads and stores go through a functional unit for
effective address computation before proceeding to
effective load and store buffers;

Loads take a second execution step to access memory,
then go to Write Result to send the value from memory
to RF and/or RS;

Stores complete their execution in their Write Result
stage (writes data to memory)

All writes occur in Write Result — simplifying Tomasulo
algorithm.


Load executed out of order with previous store: assume
address computed in program order. When Load
address has been computed, it can be compared with A
fields in active Store buffers: in the case of a match,
Load is not sent to Load buffer until conflicting store
completes.

Stores must check for matching addresses in both Load
and Store buffers (dynamic disambiguation, alternative
to static disambiguation performed by the compiler)

Drawback: amount of hardware required.

Load executed out of order with previous store: assume
address computed in program order. When Load
address has been computed, it can be compared with A
fields in active Store buffers: in the case of a match,
Load is not sent to Load buffer until conflicting store
completes.

Stores must check for matching addresses in both Load
and Store buffers (dynamic disambiguation, alternative
to static disambiguation performed by the compiler)

Drawback: amount of hardware required.

Each RS must contain a fast associative buffer; single
CDB may limit performance.


SCOREBOARD CLASSIC:

- per fare l'issue la add deve aspettare che la mult legga

|  | Issue | Read Op | Exec Co. | Write R. |
| :--- | :---: | :---: | :---: | :---: |
| LD F6 32+ R2 | 1 | 2 | 3 | 4 |
| LD F2 45+ R3 | 5 | 6 | 7 | 8 |
| MULTD F0 F4 F2 | 6 | 9 | 19 | 20 |
| ADD F2 F8 F6 | 9 | 10 | 11 | 12 |
| DIVD F12 F0 F6 | 10 | 21 | 31 | 32 |
| SUBD F6 F8 F2 | 11 | 13 | 14 | 22 |



STANDARD TOMASULO:


| Instruction | ISSUE | START EXE | WB |
| :--- | :---: | :---: | :---: |
| I1: LD F6 32+ R2 | 1 | 2 | 5 |
| I2: LD F2 45+ R3 | 2 | 6 | 9 |
| I3: MULTD F0 F4 F3 | 3 | 4 | 15 |
| 14: ADD F8 F2 F6 | 4 | 10 | 16 |
| 15: DIVD F12 F8 F0 | 5 | 17 | 28 |
| 16: SUBD F8 F6 F2 | 17 | 18 | 23 |

The table is correct. 
One of the configurations that can respect the shown table is
RS1, RS2 + 1 LDU (3cc)
RS3, RS4 + 1 MUL (11cc)
RS5 + 1 ADD (5cc) 
Consider structural hazards for RS, FU and CDB.


## Lec8 Dynamic Scheduling TOMASULO 

The idea in spaghettata mode is: I want to dynamically schedule some operation before others. Why? It can happen that an instruction $A$ is blocking another instruction $B$ because everything is pipelined and the operands of $A$ are used somewhere. If $B$ has its operands available, we would like to execute it (control flow permitting). To do this we would like to "save" $A$ so that we can execute later, when the resources will be available. To do so we need buffers . These buffers are called "Reservation Stations". The mechanism of "How damn will the saved operation be woken up?" is based on a "broadcast system" called "Common Data Bus".

Main features: 

- Like scoreboard the goal is the same: high performance w/o special compilers.
- Decentralization of the control unit distributing the buffers among FUs (vs. centralized in scoreboard)
- **register renaming** is a technique that abstracts logical registers from physical registers. Every logical register has a set of physical registers associated with it.
- Register Renaming allows to avoid WAR and WAW hazards
- The concept explained in spaghettata mode: "I'm a FU and I'm waiting for an operand which is used atm by another FU. I can **abstract** over the register and use something like a **pointer**"
- Reservation stations (RS) allow for register renaming. 
- RS permit the CPU to fetch and re-use a data value as soon as it has been computed, rather than waiting for it to be stored in a register and re-read.
- Registers names which are currently used by other FU, are removed ("renamed") in Reservation Stations




- IN-ORDER ISSUE
- OUT-OF-ORDER EXECUTION
- OUT-OF-ORDER COMPLETION
- REGISTER RENAMING based on Reservation Stations to avoid WAR and WAW hazards
- Results dispatched to RESERVATION STATIONS and to RF through the Common Data Bus
- Control is distributed on Reservation Stations
- Reservation Stations offer a sort of data forwarding!




### 17 - 04 

data dependences that cannot be hidden with bypassing or forwarding cause hardware stalls of the pipeline • Solution: allow instructions behind a stall to proceed – HW rearranges the instruction execution to reduce stalls • Enables out-of-order execution and completion (commit) – Out-of order execution introduces possibility of WAR, WAW data hazards.

Suppose a data structure keeps track of all the instructions in all the functional units The following checks need to be made before the Issue stage can dispatch an instruction • Is the required function unit available? • Is the input data available? → RAW? • Is it safe to write the destination? → WAR? WAW? • Is there a structural conflict at the WB stage?


Execution Process of Scoreboard: 

- **Issue**: fu is free (structural) and check WAW
- **Read operands**: checks availability of source operands and resolve RAW hazards dynamically with out-of-order execution
- **Execution**: fu notifies the scoreboard when the instruction is completed
- **Write result**: scoreboard checks WAR hazards and stalls the completing instruction if necessary

Issue always in order, execution out of order. This is an in-order-issue architecture. 

### Tomasulo pipeline 

| ISSUE | EXECUTION | WRITE |
| :---: | :---: | :---: |
|   Get Instruction from  Queue and Rename  Registers  | Execute and Watch CDB| Write on CDB|
|   Structural RSs check WAW and WAR solved  by Renaming  (!!!in-order-issue!!!) |   Check for Struct on FUs RAW delaying Struct check on CDB |   (FUs will hold results unless  CDB free)  RSs/FUs marked free  |

- **waw** and **war** are automagically solved by renaming!!!! we keep only the RAWs !! 

### Tomasulo 

another approach to eliminate stalls. 

It combines scoreboard with register renaming. 
Execution Process of Scoreboard: 

- **Issue**: it sends operands to the reservation station and performs register renaming.
- **Execution**: executes when operands on CDB are available 
- **Write result**: When result is available, write it to the CDB


example


| Instruction | ISSUE | $\begin{array}{c}\text { START } \\\text { EXE }\end{array}$ | WB | Hazards Type | RSi | Unit |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: |
| I1: LD $F1, 0($R1) | $\mathbf{1}$ | $\mathbf{2}$ | $\mathbf{5}$ |  | RS1 | LDU1 |
| I2: FADD $F2, $F2, $F3 | $\mathbf{2}$ | $\mathbf{3}$ | $\mathbf{6}$ |  | RS4 | FPU1 |
| I3: ADDI $R3, $R3, 8 | $\mathbf{3}$ | $\mathbf{4}$ | $\mathbf{7}$ | Struct CDB | RS7 | ALU1 |
| I4: LD $F4, 0(R2) | $\mathbf{4}$ | $\mathbf{5}$ | $\mathbf{8}$ |  | RS2 | LDU2 |
| 15: FADD $F5, $F4, $F2 | $\mathbf{5}$ | $\mathbf{9}$ | $\mathbf{1 2}$ | RAW $F4, RAW $F2 | RS5 | FPU1 |
| I6: FMULT $F6, $F1, $F4 | $\mathbf{6}$ | $\mathbf{9}$ | $\mathbf{1 3}$ | RAW $F4, Struct CDB | RS6 | FPU2 |
| 17: ADDI $R5, $R5, 1 | $\mathbf{7}$ | $\mathbf{8}$ | $\mathbf{9}$ |  | RS8 | ALU1 |
| I8: LD $R6, 0($R4) | $\mathbf{8}$ | $\mathbf{9}$ | $\mathbf{1 4}$ | Struct CDB | RS1 | LDU1 |
| I9: SD $F6, 0($R5) | $\mathbf{9}$ | $\mathbf{1 4}$ | $\mathbf{1 7}$ | RAW $F6 | RS2 | LDU2 |
| I10: SD $F5, 0($R6) | $\mathbf{1 0}$ | $\mathbf{1 5}$ | $\mathbf{1 8}$ | RAW $F5, RAW $R6 | RS3 | LDU1 |


### Register renaming  From wikipedia: 

```c
r1 = m[1024]
r1 = r1 + 2
m[1032] = r1
r1 = m[2048]
r1 = r1 + 4
m[2056] = r1
```

The instructions in the final three lines are independent of the first three instructions, but the processor cannot finish `r1 = m[2048]` until the preceding `m[1032] = r1` is done.
This restriction is eliminated by changing the names of some of the registers:

```c
r1 = m[1024]
r1 = r1 + 2
m[1032] = r1
r2 = m[2048]
r2 = r2 + 4
m[2056] = r2
```

In addition to eliminating data dependencies between instructions, register renaming provides several other advantages: it allows for speculative execution, stalls reduction, instruction scheduling semplification and reduction of explicit load and store operations. 


Just a convention in the exercises. 
While you are checking for RAW hazards if there is between I1-I3, I2-I3 on the same register, you only consider the raw from with the last WRITE so in this case you will only report I2-I3 and not I1-I3 or others previous writes.



# HW-based speculation 

HW-based Speculation combines what we have seen so far in this course + Speculation:

- Dynamic Branch Prediction 
- Dynamic Scheduling
- Speculation

Speculation consists to issue and execute instructions dependent on a branch before the branch outcome is known to allow instructions to execute out-of-order but to force them to commit in-order. 

When an instruction is no longer speculative, we allow it to update the register file or memory (instruction commit).
Outcome of branches is speculated and program is executed as if speculation was correct.
Out of order means always "buffer". In this case we use a "**Reorder Buffer**" which holds instructions in FIFO order. 
Each entry holds program counter, instruction type, destination register specifier and value if any, and exception status (info often compressed to save hardware). 

The reorder buffer is added over Tomasulo Algorithm: 

1. Issue: 
	- Get instruction from FP Op Queue 
	- If reservation station and reorder buffer slot are free, issue instruction and send operands and reorder buffer number for destination. 
	- This stage is sometimes called "dispatch".

2. Execution: 
	- Operate on operands (EX) 
	- When both operands are ready, then execute. 
	- If not ready, watch CDB for the result. 
	- When both are in reservation station, execute. 
	- Checks RAW 
	- This stage is sometimes called "issue".

3. Write result: 
	- Finish execution (WB) 
	- Write on Common Data Bus to all awaiting FUs and reorder buffer. 
	- Mark reservation station available. 

4. **Commit**: 
	- Update register with reorder result 
	- When instruction at the head of the reorder buffer and result present, update register with the result (or store to memory). 
	- Remove instruction from reorder buffer. 
	- Mispredicted branch flushes reorder buffer. 


"Instead of processing instructions strictly in the sequential program order, the CPU executes them as soon as all required resources are available. While the execution unit of the current operation is occupied, other execution units can run ahead."


![](images/02a04682daf1552de03e0e67f6af3f25.png){width=50%}


With Tomasulo we are still bounded by branches ! Tomasulo permits out of order execution of instruction that **surely** are executed. ReOrder Buffer permits to handle branches using speculation, since the fundamental concept is to have a buffer where we can temporaly store already executed instruction that are commited depending on the outcome of the branch. 



### Tomasulo with ROB 

|                                                 ISSUE                                                  |                         EXECUTION                         |                             WRITE                             |                                  Сомміт                                   |
|:------------------------------------------------------------------------------------------------------:|:---------------------------------------------------------:|:-------------------------------------------------------------:|:-------------------------------------------------------------------------:|
|              Get Instruction  from Queue and  Rename  Registers  Add Instruction  to ROB               |                  Execute and Watch  CDB                   |                   Write on CDB Write on ROB                   | Update register with  result (or store to  memory) remove Instr from  ROB |
| Structural RSs  check Structural ROB  check WAW and WAR  solved by  Renaming  (!!!in-order-  issue!!!) | Check for Struct on  FUs RAW delaying Struct check on CDB | (FUs will hold results  unless CDB free)  RSs/FUs marked free |             In-order commit Mispredicted branch  flushes ROB              |


- waw and war are automagically solved by renaming!!!! we keep only the RAWs !! 
nel clock di commit una instruzione dopo puó giá iniziare a committare 
- in-order commit using the "index" of ROB 
- remember to check **struct hazards** also for the **ROB** 
