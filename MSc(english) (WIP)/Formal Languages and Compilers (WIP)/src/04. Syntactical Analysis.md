






# Machine net and building the ELR syntax Analyzer

The construction of the pilot graph in the PDA (Pushdown Automaton) involves the following steps:

-   The pilot, or driver, controls the PDA and guides it through the different states.
-   In each macro-state (m-state), the pilot incorporates all the information about any possible phrase form that can be reached by the PDA in that state.
-   Each m-state contains machine states with look-ahead (prospection) capability, which allow the PDA to determine which characters we expect to see in the input at reduction time. These states correspond to the "followers" in the "follow" set (A) that we have seen before.
-   The m-states are used to build a few analysis threads in the stack, which correspond to possible derivations.
-   The PDA uses the information stored in the pilot graph and in the stack to perform computations and build paths with e-arcs at each machine change, labeled with the scanned string.

There are three problems that must be verified for determinism in the pilot graph:

-   Shift-reduce conflict: When a final state is reached and a terminal symbol is exiting the m-state.
-   Reduce-reduce conflict: When a state has two or more moves with the same lookahead.
-   (Less frequently) Two or more paths that merge into one state with non-disjoint lookahead.

If the determinism test is passed, the PDA can analyze the string deterministically.


Machine net is an alternative way to show the rules of the grammar. 

ILL and ILR different way to build a parser. 

ILR recognize longest prefix and then match one of the machine nets. And then makes a reduction. 

First of all initial state. A closure is the set of all candidates that can be find starting from the init state and ''looking ahead''. Candidate is a way that ILR uses to verify the match is correct. 

A state can have more candidates. ILR looks multiple candidates in parallel. $C=<q,r>$ where $q$ is a state . A closure is all possible candidates of a given states. 

ILR uses ''lookahead'' symbols, which guarantee that the match is correct. 

1) you make closure to create initial state
2) while you have a state unleft to process, for each symbols inside the set of terminal/non terminal characters, if we have a transition that goes from one of the states in the ''macrostate" then we create a new transition and a new state. And the items of the new state are the closure of the original candidates but ''advanced''. 
3) we reapeat this process until we finish states


A language is ELR-1 iff: 

- no left-most recursion : no machine where the init state has no terminals transitions 
- the pilot is STP (single transition property): there is only "destination candidate" foreach transition 
- no conflicts: there are 3 types of conflict:
	- reduce-reduce conflict: conflict when same lookahead symbol for different productions 
	- shift-reduce conflict: transition to another state with a character $x$ and there is also a final state with lookahead $x$ . "the pilot can't know if it has finished or not". 
	- convergence conflict: multiple transitions reach same state with different lookahead.  

