
### LL(k) condition 

A descending LL(k) parser reads text from left to right with left derivation (Leftmost). $k$ specifies the number of characters in prospecting.

A descending parser is said to be $LL(k)$ if at every point in the machine network where there are multiple possible paths to take, it is possible to determine which path to choose by looking at the next k characters in the input. This means that the guide sets (sets of characters that can appear next) of length k are disjoint for the different paths at the junction. 

A grammar has the LL(1) property if each state of the machines on the network satisfies the LL(1) condition.
To be LL(1), a grammar must be unambiguous (remedies on page 49 of the book) and without left recursions.

--- 

We know the same (syntax) tree corresponds to many derivations, notably the leftmost and rightmost ones, as well as to less relevant others that proceed in a zigzag order. Depending on the derivation being leftmost or rightmost and on the order it is constructed, we obtain two important parser classes. top-down analysis Constructs the leftmost derivation by starting from the axiom, i.e., the root of the tree, and growing the tree towards the leaves; each step of the algorithm corresponds to a derivation step. bottom-up analysis Constructs the rightmost derivation but in the reversed order, i.e., from the leaves to the root of the tree; each step corresponds to a reduction. The complete algorithms are described in the next sections. Here their functioning is best explained by an example.



- This part of the course is focused on parsing procedures that produce the syntax tree of a sentence
- Parsing has little interest for regular languages because their syntax structure is usually predeterminate, whereas for context-free languages any tree structure is possible
-   Pushdown stack-based automatas algorithms are divided into the classes, depending on the construction order of syntax tree

	- bottom-up (LR(k) or shift–reduce) 
	- top-down (LL(k) or predictive)


-   The focus is on grammars with regular expressions in the right parts of their rules, known as extended context-free form (EBNF)

#### The main goal of a syntax analyzer or parser is to determine if a source string is in the language L(G) of a given grammar G, and if so, to compute a derivation or syntax tree

- If the string is not in the language, the parser stops and prints an error message (The parser may also include error recovery features, such as skipping over substrings contaminated by errors)


 The approach to parsing presented in the text is based on representing the grammar as a Machine net


Therefore
a machine net M = {MS , MA , . . .} is essentially a notational variant of a grammar,
and we may go on using already known concepts such as derivation and reduction.


## Look-Ahead

As said, a set of look-ahead characters is associated to each PDA parser configuration. Without going into details, we assume that such configuration is encoded by one or more machine states. Remember that multiple such states are possibly entered by the parser after processing some text. In what follows we consider the look-ahead set of each state separately.

A pair `(state, token)` is named a candidate (also known as item). More precisely a candidate is a pair `(qB, a)` in `Q × (Σ ∪ { EOF })`. The intended meaning is that token `a` is a legal look-ahead for the current activation of machine `MB` in state `qB`. When parsing begins, the initial state of the axiomatic machine `MS` is encoded by candidate `(0S, EOF)`, which says that the end-of-text character is expected when the entire input is reduced to the axiom `S`.

To calculate the candidates for a given grammar or machine net, we use a function traditionally named closure.


# Bottom-Up Deterministic Analysis (ELR(1))


An LR(1) parser interprets a string based on the same information as an LR(0) and, in addition, on the knowledge of the
subsequent character (called prospecting).
An ambiguous grammar cannot be recognized by an LR(1) parser. 



--- 

The construction of deterministic bottom-up algorithms is widely applied to automatically implement parsers for a given grammar. The formal condition for this is the LR(k) condition defined by Knuth, where k ≥ 0 specifies how many consecutive characters are inspected to let the parser move deterministically.

In this case, we consider EBNF grammars and assume k = 1, referred to as ELR(1). The language family accepted by the parsers of type LR(1) (or ELR(1)) is exactly the family DET of deterministic context-free languages.

The ELR(1) parsers implement a deterministic automaton equipped with a pushdown stack and a set of internal states, referred to as macro-states. An m-state consists of a set of candidates. The automaton performs a series of moves of two types: a shift move and a reduce move.

A shift move reads an incoming character, applies a state-transition function to compute the next m-state, and then pushes the token and the next m-state onto the stack. A reduce move applies as soon as the sequence of top-most stack symbols matches the sequence of character labels of a recognizing path in a machine MA, under the condition that the current token is present in the current look-ahead set.

The first condition for determinism is that in every parser configuration, if a shift is permitted then a reduction is impossible. The second condition is that in every configuration, at most one reduction is possible.

A reduction move is also responsible for growing the fragment of the syntax tree that the parser has so far computed. To update the stack, a reduction move performs several actions: it pops the matched top-most part of the stack, then pushes the nonterminal symbol recognized and the next m-state onto the stack. It is important to note that a reduction does not consume the current token, which will be checked and consumed by the subsequent shift move that scans the input.


An EBNF grammar or its machine net meets the condition ELR(1) if the corresponding pilot satisfies the two following requirements:
1. Every m-state I satisfies the next two clauses:
- no shift–reduce conflict: Each reduction candidate has a look-ahead disjoint from the set of shift (movement) terminal symbols. DA FIXARE
- no reduce–reduce conflict: If there are two reduction candidates, their prospecting sets are disjoint DA FIXARE



# Machine net and building the ELR syntax Analyzer

The construction of the pilot graph in the PDA (Pushdown Automaton) involves the following steps:

-   The pilot, or driver, controls the PDA and guides it through the different states.
-   In each macro-state (m-state), the pilot incorporates all the information about any possible phrase form that can be reached by the PDA in that state.
-   Each m-state contains machine states with look-ahead (prospection) capability, which allow the PDA to determine which characters we expect to see in the input at reduction time. These states correspond to the "followers" in the "follow" set (A) that we have seen before.
-   The m-states are used to build a few analysis threads in the stack, which correspond to possible derivations.
-   The PDA uses the information stored in the pilot graph and in the stack to perform computations and build paths with e-arcs at each machine change, labeled with the scanned string.

There are three problems that must be verified for determinism in the pilot graph:

-   Shift-reduce conflict: When a final state is reached and a terminal symbol is exiting the m-state.
-   Reduce-reduce conflict: When a state has two or more moves with the same lookahead.
-   (Less frequently) Two or more paths that merge into one state with non-disjoint lookahead.

If the determinism test is passed, the PDA can analyze the string deterministically.


Machine net is an alternative way to show the rules of the grammar. 

ILL and ILR different way to build a parser. 

ILR recognize longest prefix and then match one of the machine nets. And then makes a reduction. 

First of all initial state. A closure is the set of all candidates that can be find starting from the init state and ''looking ahead''. Candidate is a way that ILR uses to verify the match is correct. 

A state can have more candidates. ILR looks multiple candidates in parallel. $C=<q,r>$ where $q$ is a state . A closure is all possible candidates of a given states. 

ILR uses ''lookahead'' symbols, which guarantee that the match is correct. 

1) you make closure to create initial state
2) while you have a state unleft to process, for each symbols inside the set of terminal/non terminal characters, if we have a transition that goes from one of the states in the ''macrostate" then we create a new transition and a new state. And the items of the new state are the closure of the original candidates but ''advanced''. 
3) we reapeat this process until we finish states


A language is ELR-1 iff: 

- no left-most recursion : no machine where the init state has no terminals transitions 
- the pilot is STP (single transition property): there is only "destination candidate" foreach transition 
- no conflicts: there are 3 types of conflict:
	- reduce-reduce conflict: conflict when same lookahead symbol for different productions 
	- shift-reduce conflict: transition to another state with a character $x$ and there is also a final state with lookahead $x$ . "the pilot can't know if it has finished or not". 
	- convergence conflict: multiple transitions reach same state with different lookahead.  



# ELL 


A simpler and very flexible top-down parsing method, traditionally called ELL(1) ,19 applies if an ELR(1) (The acronym means Extended, Left to right, Leftmost, with length of look-ahead equal to one.) grammar satisfies further conditions. Although less general than the ELR(1), this method has several assets, primarily the ability to anticipate parsing decisions thus offering a better support for syntax-directed translation, and to be implemented by a neat modular structure made of recursive procedures that mirror the graphs of network machines.

A machine net M meets the ELL(1) condition if the following three clauses are satisfied:

1) there are no left-recursive derivations
2) the net meets the ELR(1) condition, i.e., it does not have either shift–reduce, or reduce–reduce, or convergence conflicts (p. 184)
3) the net has the single-transition property (STP)





