# Lab 1 from Cattaneo

Lab is 20% of the exam. 

Some applications: 
- The standard regular expression syntax 
- Standard unix tools for text editing 
- Parser generation with flex and bison 
- The internal organization and workflow of a real-world compiler 
- How to modify and extend a simple compiler called ACSE

Regex basics:
- ```x``` the ```x``` character 
- ```.``` any character except newline
- ```[xyz]``` means ```x``` or ```y``` or ```z``` 
- ```[a-z]``` any character between ```a``` and ```z``` 
- ```[^a-z]``` any character except those between ```a``` and ```z```

Said ```R``` a regular expression:
- ```RS``` concatenation of ```R``` and ```S```
- ```R|S``` either ```R``` or ```S``` 
- ```R*``` zero or more occurrences of ```R```
- ```R+``` one or more occurrences of ```R``` 
- ```R?``` zero or one occurrence of ```R ```
- ```R{m,n}``` a number or ```R``` occurrences ranging from ```n``` to ```m ```
- ```R{n,}``` at least n occurrences 
- ```R{n}``` exactly n occurrences of ```R```

## Flex 

It's implemented as non-deterministic finite state automaton. 

![](images/4741ab5c6ef0e10af277ee29b77d8f62.png)

- definitions: where you can declare useful REs
- rules: most important part where you bind RE combinations to actions 
- user code: C code

Each part is separated by ```%%```  


Longest matching rule 
The flex scanner in case of more than one match (with more one rules) the longer match will always win: if a longer regular expression match an expression and then others regular expression match subsets of the expression, the longer rule willl have precedence. 

the first rule 


Flex breaks up the input into individual tokens that are then passed to the parser (in our case we use Bison) for further processing.

# Bison

It reads a specification of a grammar for a particular programming language or input format, and generates a parser which can recognize and parse input written in that language or format. 

- prologue: useful place where to put header file inclusions and variable declarations
- definitions
- rules 
- user code 

````C
%{
//prologue and headers 
}%
// definitions
%%
//rules like a context-free grammar 
not_terminal : terminal1 
				   | terminal2 TOKEN_A  
				   | terminal3 { /* C code */ }
%%
//user code
````


Very similar to grammar ... uppercase tokens are non terminals and lowercase tokens are terminals symbols. 

You can add semantic actions for each grammar rule. 

Byson uses bottom-up parsing: it always gives precedence to the inner-most rule. 



# Lab 24/11 

## Practical stuff related to ACSE

ACSE is a simplified compiler in order to reduce the effort to understand how compilers work. ACSE accepts a C-like source language called LANCE:   
• very small subset of C99   
• standard set of arithmetic/logic/comparison operators   
• reduced set of control flow statements (while, do-whi le, if)   
• only one scalar type (int)   
• only one aggregate type (array of ints)   
- only two I/O operations:   
	- `read(var)` stores into var an integer read from standard   
	- `write(var)` writes var to standard output writing


LANCE produces a RISC-like assembly language: 

|Type  | Operands  | | 
|:--:|:---:|:--:|
| Ternary  | 1 destination and 2 source registers   | ADD R3 R1 R2  |
| Binary   | 1 destination and 1 source register, and 1 immediate operand  | ADD R3 R1 #4| 
| Unary   |1 destination and 1 address operand (label) |  LOAD R1 L0   |
| Jump   |1 address operand   |BEQ LO|

Jump instructions:
- BT: unconditional branch
- BEQ: branch if last result was zero 
- BNE: branch if last result was not zero

Using `( )` to point to the memory address. 

![](Pasted%20image%2020221227164252.png)

Special registers:

- zero 
- status word or PSW:
	- N
	- Z
	- V
	- C



ACSE works using **asm** which translates assebly to machine code and **mace** which is a simulator of the fictional MACE process. A real-world example of a compiler is LLVM.   
Compiler translates a program written in a language and it's organized as a pipeline: 

- front-end: source language into intermediate forms
- middle-end: where transformations and optimizations are applied (for example vectorization)
- back-end

![](4f79b1f91304fb5f4fece5d0077cf069.png)

The theory part of the course mainly focused on the frontend: 

![](96af7004edbe420cf8c31fb1fdd552b7.png)



--- 

Our workflow? 

In the context of an ACSE compiler, Bison and Flex would likely be used to build the front-end of the compiler, which would be responsible for translating ACSE code into a form that can be understood and processed by the rest of the compiler. The parser generated by Bison would be responsible for recognizing and parsing the ACSE code, and the lexical analyzer generated by Flex would be responsible for breaking the code up into individual tokens for further processing.

--- 

How works ACSE? 

- Front-end: the source code is tokenized by a flex-generated scanner O The stream of tokens is parsed by a bison-generated parser The code is translated to a temporary intermediate o representation by the semantic actions in the parser 
- No middle-end since no optimizations are made
- Back-end: the intermediate representation is normalized to account for O physical limitations of the MACE processor Each instruction is printed out producing the assembly file O There is 


## ACSE actual code 

`Acse.lex` : flex source (scanner)
`Acse.y`: Bison syntax grammar of LANCE in `Acse.y` . The semantic actions are responsible for the actual translation from LANCE to assembly
`codegen`: instruction generation functions: `aze_gencode.h`

# 29 11 

The parser (Bison) modifies the intermediate languages made of variable and instructions list. Then backend process it. 

Precedence and associativity of expressions are handled by Bison. 


Constant folding: optimization to "merge" constants at compile time.  
To do this we use a structure which memorize the "value" and the type "IMMEDIATE|REGISTER". If at compile time there is a sum of two immediate, they will merged inside a single immediate.

To do this, you will use: 

````cpp
handle_bin_numeric_op()  //Arithmetic and logical operations   
handle_binary_comparison()   // Comparisons
````

Remember: yyerror() is the standard Bison function for signaling   
syntax errors. The YYERROR macro is what actually stops the   
syntactic action. *

We can use `getVariable(program,char * id)`;

````cpp
typedef struct t_axe_variable  {
	int type;   
	int isArray;   
	int arraySize;   
	int init_val;   
	char *ID;   
	t axe label *label ID;   
} t_axe_variable;
````



# 12 01 lab 


at the exam the grammar part is the most easy part. The difficult part is the semantic action. 

Tip: It's always useful to "de-sugar" a construct you are implementing   
to clear up any doubt you might have about its implementation

for syntax sugar -> any for can be replaced with while 


If in Bison part we use " $2" we refer to the second token

Semantic actions are independent blocks or scopes   
Variables declared in a semantic action are local to that action!


Things we can do: 

- global var: super easy to apply but it doesn't work if the statement is nestable 
- global stack: 
	- `t_list *save_stack = NULL`
	- `addFirst(save_stack,INTDATA(<var>))`
	- `int <var>=LINTDATA(save_stack)`
	- `removeFirst(save_stack);` 
- semantic value as a variable: we use 


![](Pasted%20image%2020221229170525.png)


# Tutoring LAB last year 

from the example tries to write always a pseudocode. 


Important concept: in this kind of exercises we never generate labels or variables. We write the code to let the compiler to generate them itself. We are not actually doing assignments now, we are just writing to the output of the compiler the instructions that will do the assignment when the program will be executed. We are translating the program, not executing. 
Because of this everything we do is using `gen_XXXX_instruction(XXXX)`  functions. 

steps: 

1) add the "keyword" to the Flex toke declaration:
	- `"keyword" { return KEYWORD_TOKEN }`
2) then in Bison ( `Acse.y`) we place the toke definition: 
	- `%TOKEN KEYWORD_TOKEN` 
3) Then you have to define the syntactic rules or modifications to existing one. 
4) Define the semantic actions needed to implement the required functionality, always in `Acse.y`. General stuff in the exam could be:
	- generate a custom structure to manage results
	- use some of the 3 possible techniques to manage nesting expressions and the "stack". 
	- modify existing code


### Example of common snippets: 

````cpp

//

return_statement : RETURN 
	{
	// INSERT ALT INSTRUCTION
	gen_halt_instruction(program);
	}
	| RETURN exp
	{
		if ($2.expression_type  == IMMEDIATE){
		gne_addi_instruction(program, top->r_return, REG_0, $2.value);   
		} else{
		gen_add_inst ruction(program, top->r_return, REG_0, $2.value, C_DIRECT_ALL);
		}
	}
````

In general if there are identifier you will to verify if it is an array or not. 
