# JPA

ORM stands for Object-Relational Mapping, and it's basically a way to interact with a relational database using an object-oriented programming model. Instead of writing SQL queries to get data from a database, you can just use objects in your code.

One of the most popular ORM frameworks for Java is JPA (Java Persistence API). JPA is basically the standard for ORM in the Java Enterprise Edition (Java EE) platform, and it makes working with a relational database really simple. You can do all the basic stuff like creating, reading, updating, and deleting data without having to write complex SQL queries. Plus, it has some awesome features like caching and lazy loading that can help you make your code run faster.

[JPA Introduction - javatpoint](https://www.javatpoint.com/jpa-introduction)


JPA auto-generates SQL code from Java code, creating correspondence between Java objects and DB tuples. This is called ORM (Object-relational mapping): 

- classes are tables
- objects instances are tables rows (tuples)
- the physical memory address of an objects is the primary key of the tuple 
- references to other objects are the foreign keys 
- methods are triggers 

````Java
//entity manager interface 
public void persist (Object entity) //creates an entity instance in the database 
public <T> T find (Class<T> entityClass, Object primaryKey) //find an entity instance by its primary key 
public void remove (Object entity); //removes the entity instance from the DB 
public void refresh (Object entity); //resets the entity instance from the DB 
//JPA uses a 'Persistence Context' as middleware between Java and the DB. This is like a cache and maybe sometimes you want to force changes: 
public void flush(); 
````

By default entities are mapped to tables with the same name and their fields to columns with the same names, but you can always change it using some annotations: 

````Java
@Entity @Table(name="SUPERHEROS")
public class Superhero {

@Column(name="REAL_NAME",nullable=false)
private String real_name;
@Transient 
private boolean isInJusticeLeague; //transient attributes are attributes that are not persisted 
...
}
````

All relationships in JPA are unidirectional, the only way to make bidirectional relationships is using two 'paired' unidirectional mappings.

- Many-to-one 
- One-to-many
- One-to-one
- Many-to-many

Sometimes @ManyToOne relationship are not necessary and they can be mapped only for consistency. 


"Select with possible NULL value and IF condition in a trigger" pattern: 

````sql
DECLARE X AS INTEGER
IFNULL(<SELECT_QUERY_HERE>, 0) INTO X

IF (X<>0)
THEN
	\\
ELSE
	\\
ENDIF;
````

When the
fetch mode is not specified, by default:
•
A single
valued relationship is fetched eagerly
•
Collection
valued relationships are loaded lazily 



-   Fetch policy
    -   Father to children element collection fetched eagerly to allow the client to recursively navigate the relationship and display the BOM tree
    -   Child to fathers fetched lazily when needed by business components (e.g., to retrieve top products)

So eager -> when there aren't many elements and you can load them runtime when needed. Few data. For small cardinality

So Lazy -> a lot of data. 


First of all you make a class for each entity. 

mapped by specify which foreign key defines this entity. 


There is also cascade type:

- PERSIST
- REFRESH
- REMOVE
- MERGE
- DETACH

### One to many

````Java
@Entity
public class B{
@Id private int id
@OneToMany(mappedBy = "java_var")
private List<A> As; //actually not only lists .. but any kind of collections 
...
}

//On the other side:

@Entity
public class A{
@Id @GeneratedValue(strategy=GenerationType.AUTO)
private int id;

@ManyToOne
@JoinColumn (name="fk") //the column where there is the foreign key
private B java_var;
...
}
````


### Many to many 

````Java
@Entity
public class B{
@Id private int id
@ManyToMany(mappedBy = "java_var")
private List<A> As; //actually not only lists .. but any kind of collections 
...
}

//On the other side:

@Entity
public class A{
@Id @GeneratedValue(strategy=GenerationType.AUTO)
private int id;

@ManyToMany
@joinTable(
	name="table_name",
	JoinColumns = @JoinColumn(name="this_entity_fk"),
	@InverseJoinColumn = @JoinColumn(name="other_fk"))
private Collection<B> java_list_of_Bs;
...
}
````


the owner in these cases is not relevant.
The N:M relationship with attributes between a parent product and its sub-products is mapped differently in the two directions.

**Parent to Children**

-   Given a product, it is necessary to retrieve all its sub-products
-   Given a product and a sub-product, it is necessary to retrieve the quantity
-   Such requirements are supported by a relationship mapped by means of an entity key element collection. Elements of the collection are of the form <Product, quantity>, so the relationship is realized through a Map with an entity of type product as the key.

**Child to Parents**

-   This is realized via an independent regular @ManyToMany unidirectional relationship mapped on the same table as the product to sub-products relationship with attribute.


In a ManyToMany mapping there is no FK column. Such a mapping is implemented by means of a join table (aka bridge table).
ManyToMany annotation must come with the mappedBy element.


  -   The inverse direction (@ManyToMany from child to fathers) is "read-only" and maintained by adding elements to element collection, which is mapped on the same table



@ManyToOne 

On "many side" we use the Foreign Key . 
On "one side" we use the name of the Java Attribute 


Ownership:

- manytomany 
- onetoone



### ManyToMany with attributes

-   In a "regular" N:M relationship, the access paths are:
    -   Fetch all instances of A given B
    -   Fetch all instances of B given A
-   In N:M with attributes, there are additional access paths:
    -   The values of the attributes of the pair <A, B> (equivalently <B,A>)
- In an object-oriented world, in which @ToMany relationships are implemented as map becomes:
-   This is realized with JPA "entity key" "element collections"
-   Element collections: they are collections not of objects but of tuples (e.g., <Product, quantity>). In many cases, the collection is a map, and an entity is used as the key index.

-   Entities key element collection are specified with the @ElementCollection annotation
-   It denotes a collection that holds a set of non-entity components of the entity. This is weaker than a @toMany collection because it does not support cascading, inverse and orphan removal 
-   The mapping is similar to a regular @ManyToMany relationship
-   It involves a join table
-   It maps the join from father to child using the @JoinColumn to specify the column holding the father PK
-   Instead of specifying the @inverseJoinColumns, it uses a @MapKeyJoinColumn annotation to specify the column holding the PK of the entity used as a map index


Map example

![](images/bdcabc300e2f04d22f42820390bc3837.png)

We can't have a traditional join table with 2 columns because we have 3 attributes: so we use a map ```Map<Product, Integer>``` . 

````Java
@Entity 
public class Order implements Serializable{
// ...

@ElementCollection(fetch = FetchType.EAGER) 
@CollectionTable(name = "product_order", 
						joinColumns = @JoinColumn(name = “orderId")) //orderId is the ID of the owner's entity 
@MapKeyJoinColumn(name = "productId") 
@Column(name = "quantity")
private Map<Product, Integer> products;

//...
}

//ON THE OTHER SIDE: 
												  
@Entity
public class Product implements Serializable {
@Id @GeneratedValue(strategy = GenerationType.AUTO)
private int productId;
private int unitPrice;

@ManyToMany 
@JoinTable (name = "product_order",
	joinColumns = @JoinColumn(name = "productId"),
	inverseJoinColumns =@JoinColumn(name = "orderId"))
private List<Order> orders; // owner of the relation

// ...	getters and setters and stuff
}
```` 

## Check the above code when you do this exercise 

Using this solution you will have (on DB side) a rich table with 3 columns. An alternative solution to this is to make manually a 'bridge entity' . 

You have to use the keyword ```@Embeddable``` (over the class) and a ```@EmbeddedId``` over the primary key of this new bridge entity, which will also contain the ID of the other two entities using ```@MapsId("id1")``` before  ```@JoinColumn(name = "id1")``` and ```@MapsId("id2") ... ``` .  
