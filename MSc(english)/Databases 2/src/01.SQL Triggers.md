# SQL Triggers 

Main paradigm: 

````
EVENT -> CONDITION -> ACTION
````

where: 

- `EVENT`: 

````sql
create trigger <trigger_name>
{before | after}
{insert | delete | update [of <column>]} on <table>
[referencing (to put aliases on old, new, etc)]
[for each {row | statement}]
[when condition]
BEGIN
[my action]
END
````

•	Use triggers to guarantee that when a specific operation is performed, related actions are performed
•	Do not define triggers that duplicate features already built into the DBMS. For example, do not define triggers to reject bad data if you can do the same checking through aeclarative integrity constraints 
Limit the size of triggers. If the logic for your trigger requires much more than 60 lines of code, it is better to include most of the code in a stored procedure and call the procedure from the trigger. Use triggers only for centralized, global operations that should be fired for the triggering statement, regardless of which user or database application issues the statement. Avoid recursive triggers if not absolutely necessary. Trigger may•
: : :  fire recursively until the DBMs runs out of memory. 

Use triggers : : : · .Yro guarantee properties of data that cannot be specified by means of integrity constraints 


Importante perché solitamente ci sono tante applicazioni diverse che
accedono allo stesso DB. Quindi se ho qualche regola da far rispettare
in generale è molto meglio averla nel DB che a livello Applicativo nelle
diverse applicazioni. Potrebbero crearsi inconsistenze e casini.



Triggers are powerfull but also complicated because cascading policies. 
They could be bugs in triggers obviously, also because a **cascading** triggers: a trigger activates another trigger. Some systems block cascading of triggers. Also it could happen **recursive cascading** . 

````SQL
CREATE TRIGGER [schema_name.]_trigger_name 
{ BEFORE | AFTER | INSTEAD OF } {INSERT |  UPDATE | DELETE} ON schema_name
{ FOR EACH ROW}
BEGIN 
{ WHEN ....}
UPDATE schema_name SET attribute_name = .... 
{ WHERE .... }
END;
````

````sql 
DROP TRIGGER trigger_name;
````

````SQL

INSERT INTO NAMES 
VALUES (23,"rick");

SELECT * FROM NAMES;
````


sito per esercitarsi: [Online SQL Compiler (tutorialspoint.com)](https://www.tutorialspoint.com/execute_sql_online.php) 

usi la keyword new per selezionare la nuova entry

> Remember that every time you have an update, you usually also have a 'where'


````sql
SELECT * FROM table1 AS X JOIN table2 AS Y ON X.attribute=Y.attribute
````


Also exist 'IF EXISTS ... ELSE ... '


Cascading is generally bad and in some DBMS is even forbidden. 


### Termination analysis

Draw down the triggering graph where each node is atrigger and each arc from a trigger i to j is present only if T_i effects may activate T_j . 

## View Materialization 

When a view is mentioned in a SELECT query the query
processor rewrites the query using the view definition,
so that the actually executed query only uses the base
tables of the view
•
When the queries to a view are more frequent than the
updates on the base tables that change the view
content, then view materialization can be an option
•
Storing the results of the query that defines a the view in a
table
•
Some systems support the CREATE MATERIALIZED
VIEW command, which makes the view automatically
materialized by the DBMS
•
An alternative is to implement the materialization by
means of triggers